

TanStack DB is a reactive client store for building super fast apps. This example will show you how to:

- **Load data** into collections using TanStack Query
- **Query data** with blazing fast live queries
- **Mutate data** with instant optimistic updates

tsx

```
import { createCollection, eq, useLiveQuery } from '@tanstack/react-db'
import { queryCollectionOptions } from '@tanstack/query-db-collection'

// Define a collection that loads data using TanStack Query
const todoCollection = createCollection(
  queryCollectionOptions({
    queryKey: ['todos'],
    queryFn: async () => {
      const response = await fetch('/api/todos')
      return response.json()
    },
    getKey: (item) => item.id,
    onUpdate: async ({ transaction }) => {
      const { original, modified } = transaction.mutations[0]
      await fetch(`/api/todos/${original.id}`, {
        method: 'PUT',
        body: JSON.stringify(modified),
      })
    },
  })
)

function Todos() {
  // Live query that updates automatically when data changes
  const { data: todos } = useLiveQuery((q) =>
    q.from({ todo: todoCollection })
     .where(({ todo }) => eq(todo.completed, false))
     .orderBy(({ todo }) => todo.createdAt, 'desc')
  )

  const toggleTodo = (todo) => {
    // Instantly applies optimistic state, then syncs to server
    todoCollection.update(todo.id, (draft) => {
      draft.completed = !draft.completed
    })
  }

  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id} onClick={() => toggleTodo(todo)}>
          {todo.text}
        </li>
      ))}
    </ul>
  )
}

```

```
import { createCollection, eq, useLiveQuery } from '@tanstack/react-db'
import { queryCollectionOptions } from '@tanstack/query-db-collection'

// Define a collection that loads data using TanStack Query
const todoCollection = createCollection(
  queryCollectionOptions({
    queryKey: ['todos'],
    queryFn: async () => {
      const response = await fetch('/api/todos')
      return response.json()
    },
    getKey: (item) => item.id,
    onUpdate: async ({ transaction }) => {
      const { original, modified } = transaction.mutations[0]
      await fetch(`/api/todos/${original.id}`, {
        method: 'PUT',
        body: JSON.stringify(modified),
      })
    },
  })
)

function Todos() {
  // Live query that updates automatically when data changes
  const { data: todos } = useLiveQuery((q) =>
    q.from({ todo: todoCollection })
     .where(({ todo }) => eq(todo.completed, false))
     .orderBy(({ todo }) => todo.createdAt, 'desc')
  )

  const toggleTodo = (todo) => {
    // Instantly applies optimistic state, then syncs to server
    todoCollection.update(todo.id, (draft) => {
      draft.completed = !draft.completed
    })
  }

  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id} onClick={() => toggleTodo(todo)}>
          {todo.text}
        </li>
      ))}
    </ul>
  )
}

[**1\. Create a Collection**](https://tanstack.com/db/latest/docs/quick-start#1-create-a-collection)

Collections store your data and handle persistence. The queryCollectionOptions loads data using TanStack Query and defines mutation handlers for server sync:

tsx

```
const todoCollection = createCollection(
  queryCollectionOptions({
    queryKey: ['todos'],
    queryFn: async () => {
      const response = await fetch('/api/todos')
      return response.json()
    },
    getKey: (item) => item.id,
    // Handle all CRUD operations
    onInsert: async ({ transaction }) => {
      const { modified: newTodo } = transaction.mutations[0]
      await fetch('/api/todos', {
        method: 'POST',
        body: JSON.stringify(newTodo),
      })
    },
    onUpdate: async ({ transaction }) => {
      const { original, modified } = transaction.mutations[0]
      await fetch(`/api/todos/${original.id}`, {
        method: 'PUT',
        body: JSON.stringify(modified),
      })
    },
    onDelete: async ({ transaction }) => {
      const { original } = transaction.mutations[0]
      await fetch(`/api/todos/${original.id}`, { method: 'DELETE' })
    },
  })
)

```

```
const todoCollection = createCollection(
  queryCollectionOptions({
    queryKey: ['todos'],
    queryFn: async () => {
      const response = await fetch('/api/todos')
      return response.json()
    },
    getKey: (item) => item.id,
    // Handle all CRUD operations
    onInsert: async ({ transaction }) => {
      const { modified: newTodo } = transaction.mutations[0]
      await fetch('/api/todos', {
        method: 'POST',
        body: JSON.stringify(newTodo),
      })
    },
    onUpdate: async ({ transaction }) => {
      const { original, modified } = transaction.mutations[0]
      await fetch(`/api/todos/${original.id}`, {
        method: 'PUT',
        body: JSON.stringify(modified),
      })
    },
    onDelete: async ({ transaction }) => {
      const { original } = transaction.mutations[0]
      await fetch(`/api/todos/${original.id}`, { method: 'DELETE' })
    },
  })
)

```

[**2\. Query with Live Queries**]

Live queries reactively update when data changes. They support filtering, sorting, joins, and transformations:

tsx

```
function TodoList() {
  // Basic filtering and sorting
  const { data: incompleteTodos } = useLiveQuery((q) =>
    q.from({ todo: todoCollection })
     .where(({ todo }) => eq(todo.completed, false))
     .orderBy(({ todo }) => todo.createdAt, 'desc')
  )

  // Transform the data
  const { data: todoSummary } = useLiveQuery((q) =>
    q.from({ todo: todoCollection })
     .select(({ todo }) => ({
       id: todo.id,
       summary: `${todo.text} (${todo.completed ? 'done' : 'pending'})`,
       priority: todo.priority || 'normal'
     }))
  )

  return <div>{/* Render todos */}</div>
}

```

```
function TodoList() {
  // Basic filtering and sorting
  const { data: incompleteTodos } = useLiveQuery((q) =>
    q.from({ todo: todoCollection })
     .where(({ todo }) => eq(todo.completed, false))
     .orderBy(({ todo }) => todo.createdAt, 'desc')
  )

  // Transform the data
  const { data: todoSummary } = useLiveQuery((q) =>
    q.from({ todo: todoCollection })
     .select(({ todo }) => ({
       id: todo.id,
       summary: `${todo.text} (${todo.completed ? 'done' : 'pending'})`,
       priority: todo.priority || 'normal'
     }))
  )

  return <div>{/* Render todos */}</div>
}

```

[**3\. Optimistic Mutations**]

Mutations apply instantly and sync to your server. If the server request fails, changes automatically roll back:

tsx

```
function TodoActions({ todo }) {
  const addTodo = () => {
    todoCollection.insert({
      id: crypto.randomUUID(),
      text: 'New todo',
      completed: false,
      createdAt: new Date(),
    })
  }

  const toggleComplete = () => {
    todoCollection.update(todo.id, (draft) => {
      draft.completed = !draft.completed
    })
  }

  const updateText = (newText) => {
    todoCollection.update(todo.id, (draft) => {
      draft.text = newText
    })
  }

  const deleteTodo = () => {
    todoCollection.delete(todo.id)
  }

  return (
    <div>
      <button onClick={addTodo}>Add Todo</button>
      <button onClick={toggleComplete}>Toggle</button>
      <button onClick={() => updateText('Updated!')}>Edit</button>
      <button onClick={deleteTodo}>Delete</button>
    </div>
  )
}

```

```
function TodoActions({ todo }) {
  const addTodo = () => {
    todoCollection.insert({
      id: crypto.randomUUID(),
      text: 'New todo',
      completed: false,
      createdAt: new Date(),
    })
  }

  const toggleComplete = () => {
    todoCollection.update(todo.id, (draft) => {
      draft.completed = !draft.completed
    })
  }

  const updateText = (newText) => {
    todoCollection.update(todo.id, (draft) => {
      draft.text = newText
    })
  }

  const deleteTodo = () => {
    todoCollection.delete(todo.id)
  }

  return (
    <div>
      <button onClick={addTodo}>Add Todo</button>
      <button onClick={toggleComplete}>Toggle</button>
      <button onClick={() => updateText('Updated!')}>Edit</button>
      <button onClick={deleteTodo}>Delete</button>
    </div>
  )
}

```

You now understand the basics of TanStack DB! The collection loads and persists data, live queries provide reactive views, and mutations give instant feedback with automatic server sync.



[**TanStack DB - Documentation**]

Welcome to the TanStack DB documentation.

TanStack DB is a reactive client store for building super fast apps on sync. It extends TanStack Query with collections, live queries and optimistic mutations.

[**Contents**](https://tanstack.com/db/latest/docs/overview#contents)

- [How it works](https://tanstack.com/db/latest/docs/overview#how-it-works) â€” understand the TanStack DB development model and how the pieces fit together
- [API reference](https://tanstack.com/db/latest/docs/overview#api-reference) â€” for the primitives and function interfaces
- [Usage examples](https://tanstack.com/db/latest/docs/overview#usage-examples) â€” examples of common usage patterns
- [More info](https://tanstack.com/db/latest/docs/overview#more-info) â€” where to find support and more information

[**How it works**](https://tanstack.com/db/latest/docs/overview#how-it-works)

TanStack DB works by:

- [defining collections](https://tanstack.com/db/latest/docs/overview#defining-collections) typed sets of objects that can be populated with data
- [using live queries](https://tanstack.com/db/latest/docs/overview#using-live-queries) to query data from/across collections
- [making optimistic mutations](https://tanstack.com/db/latest/docs/overview#making-optimistic-mutations) using transactional mutators

tsx

```
// Define collections to load data into
const todoCollection = createCollection({
  // ...your config
  onUpdate: updateMutationFn,
})

const Todos = () => {
  // Bind data using live queries
  const { data: todos } = useLiveQuery((q) =>
    q.from({ todo: todoCollection }).where(({ todo }) => todo.completed)
  )

  const complete = (todo) => {
    // Instantly applies optimistic state
    todoCollection.update(todo.id, (draft) => {
      draft.completed = true
    })
  }

  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id} onClick={() => complete(todo)}>
          {todo.text}
        </li>
      ))}
    </ul>
  )
}

```

```
// Define collections to load data into
const todoCollection = createCollection({
  // ...your config
  onUpdate: updateMutationFn,
})

const Todos = () => {
  // Bind data using live queries
  const { data: todos } = useLiveQuery((q) =>
    q.from({ todo: todoCollection }).where(({ todo }) => todo.completed)
  )

  const complete = (todo) => {
    // Instantly applies optimistic state
    todoCollection.update(todo.id, (draft) => {
      draft.completed = true
    })
  }

  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id} onClick={() => complete(todo)}>
          {todo.text}
        </li>
      ))}
    </ul>
  )
}

```

[**Defining collections**]

Collections are typed sets of objects that can be populated with data. They're designed to de-couple loading data into your app from binding data to your components.

Collections can be populated in many ways, including:

- fetching data, for example [from API endpoints using TanStack Query](https://tanstack.com/query/latest)
- syncing data, for example [using a sync engine like ElectricSQL](https://electric-sql.com/)
- storing local data, for example [using localStorage for user preferences and settings](https://tanstack.com/db/latest/docs/overview#localstoragecollection) or [in-memory client data or UI state](https://tanstack.com/db/latest/docs/overview#localonlycollection)
- from live collection queries, creating [derived collections as materialised views](https://tanstack.com/db/latest/docs/overview#using-live-queries)

Once you have your data in collections, you can query across them using live queries in your components.

[**Using live queries**](https://tanstack.com/db/latest/docs/overview#using-live-queries)

Live queries are used to query data out of collections. Live queries are reactive: when the underlying data changes in a way that would affect the query result, the result is incrementally updated and returned from the query, triggering a re-render.

TanStack DB live queries are implemented using [d2ts](https://github.com/electric-sql/d2ts), a Typescript implementation of differential dataflow. This allows the query results to update _incrementally_ (rather than by re-running the whole query). This makes them blazing fast, usually sub-millisecond, even for highly complex queries.

Live queries support joins across collections. This allows you to:

1. load normalised data into collections and then de-normalise it through queries; simplifying your backend by avoiding the need for bespoke API endpoints that match your client
2. join data from multiple sources; for example, syncing some data out of a database, fetching some other data from an external API and then joining these into a unified data model for your front-end code

Every query returns another collection which can _also_ be queried.

Collections support insert, update and delete operations. When called, by default they trigger the corresponding onInsert, onUpdate, onDelete handlers which are responsible for writing the mutation to the backend.

ts

```
// Define collection with persistence handlers
const todoCollection = createCollection({
  id: "todos",
  // ... other config
  onUpdate: async ({ transaction }) => {
    const { original, changes } = transaction.mutations[0]
    await api.todos.update(original.id, changes)
  },
})

// Immediately applies optimistic state
todoCollection.update(todo.id, (draft) => {
  draft.completed = true
})

```

```
// Define collection with persistence handlers
const todoCollection = createCollection({
  id: "todos",
  // ... other config
  onUpdate: async ({ transaction }) => {
    const { original, changes } = transaction.mutations[0]
    await api.todos.update(original.id, changes)
  },
})

// Immediately applies optimistic state
todoCollection.update(todo.id, (draft) => {
  draft.completed = true
})

```

Rather than mutating the collection data directly, the collection internally treats its synced/loaded data as immutable and maintains a separate set of local mutations as optimistic state. When live queries read from the collection, they see a local view that overlays the local optimistic mutations on-top-of the immutable synced data.

The optimistic state is held until the onUpdate (in this case) handler resolves - at which point the data is persisted to the server and synced back to the local collection.

If the handler throws an error, the optimistic state is rolled back.

[**Explicit transactions**]

Mutations are based on a Transaction primitive.

For simple state changes, directly mutating the collection and persisting with the operator handlers is enough.

But for more complex use cases, you can directly create custom actions with createOptimisticAction or custom transactions with createTransaction. This lets you do things such as do transactions with multiple mutations across multiple collections, do chained transactions w/ intermediate rollbacks, etc.

For example, in the following code, the mutationFn first sends the write to the server using await api.todos.update(updatedTodo) and then calls await collection.refetch() to trigger a re-fetch of the collection contents using TanStack Query. When this second await resolves, the collection is up-to-date with the latest changes and the optimistic state is safely discarded.

ts

```
const updateTodo = createOptimisticAction<{ id: string }>({
  onMutate,
  mutationFn: async ({ transaction }) => {
    const { collection, modified: updatedTodo } = transaction.mutations[0]

    await api.todos.update(updatedTodo)
    await collection.refetch()
  },
})

```

```
const updateTodo = createOptimisticAction<{ id: string }>({
  onMutate,
  mutationFn: async ({ transaction }) => {
    const { collection, modified: updatedTodo } = transaction.mutations[0]

    await api.todos.update(updatedTodo)
    await collection.refetch()
  },
})

```

[**Uni-directional data flow**](https://tanstack.com/db/latest/docs/overview#uni-directional-data-flow)

This combines to support a model of uni-directional data flow, extending the redux/flux style state management pattern beyond the client, to take in the server as well:


With an instant inner loop of optimistic state, superseded in time by the slower outer loop of persisting to the server and syncing the updated server state back into the collection.

[**API reference**](https://tanstack.com/db/latest/docs/overview#api-reference) [**Collections**](https://tanstack.com/db/latest/docs/overview#collections)

There are a number of built-in collection types:

1. [QueryCollection](https://tanstack.com/db/latest/docs/overview#querycollection) to load data into collections using [TanStack Query](https://tanstack.com/query)
2. [ElectricCollection](https://tanstack.com/db/latest/docs/overview#electriccollection) to sync data into collections using [ElectricSQL](https://electric-sql.com/)
3. [TrailBaseCollection](https://tanstack.com/db/latest/docs/overview#trailbasecollection) to sync data into collections using [TrailBase](https://trailbase.io/)
4. [LocalStorageCollection](https://tanstack.com/db/latest/docs/overview#localstoragecollection) for small amounts of local-only state that syncs across browser tabs
5. [LocalOnlyCollection](https://tanstack.com/db/latest/docs/overview#localonlycollection) for in-memory client data or UI state

You can also use:

- use live collection queries to [derive collections from other collections](https://tanstack.com/db/latest/docs/overview#derived-collections)
- the [base Collection](https://tanstack.com/db/latest/docs/overview#base-collection) to define your own collection types

[**Collection schemas**](https://tanstack.com/db/latest/docs/overview#collection-schemas)

All collections optionally (though strongly recommended) support adding a schema.

If provided, this must be a [Standard Schema](https://standardschema.dev/) compatible schema instance, such as a [Zod](https://zod.dev/) or [Effect](https://effect.website/docs/schema/introduction/) schema.

The collection will use the schema to do client-side validation of optimistic mutations.

The collection will use the schema for its type so if you provide a schema, you can't also pass in an explicit
type (e.g. createCollection<Todo>()).

[**QueryCollection**](https://tanstack.com/db/latest/docs/overview#querycollection)

[TanStack Query](https://tanstack.com/query) fetches data using managed queries. Use queryCollectionOptions to fetch data into a collection using TanStack Query:

ts

```
import { createCollection } from "@tanstack/react-db"
import { queryCollectionOptions } from "@tanstack/query-db-collection"

const todoCollection = createCollection(
  queryCollectionOptions({
    queryKey: ["todoItems"],
    queryFn: async () => fetch("/api/todos"),
    getKey: (item) => item.id,
    schema: todoSchema, // any standard schema
  })
)

```

```
import { createCollection } from "@tanstack/react-db"
import { queryCollectionOptions } from "@tanstack/query-db-collection"

const todoCollection = createCollection(
  queryCollectionOptions({
    queryKey: ["todoItems"],
    queryFn: async () => fetch("/api/todos"),
    getKey: (item) => item.id,
    schema: todoSchema, // any standard schema
  })
)

```

The collection will be populated with the query results.

[**ElectricCollection**]

[Electric](https://electric-sql.com/) is a read-path sync engine for Postgres. It allows you to sync subsets of data out of a Postgres database, [through your API](https://electric-sql.com/blog/2024/11/21/local-first-with-your-existing-api), into a TanStack DB collection.

Electric's main primitive for sync is a [Shape](https://electric-sql.com/docs/guides/shapes). Use electricCollectionOptions to sync a shape into a collection:

ts

```
import { createCollection } from "@tanstack/react-db"
import { electricCollectionOptions } from "@tanstack/electric-db-collection"

export const todoCollection = createCollection(
  electricCollectionOptions({
    id: "todos",
    shapeOptions: {
      url: "https://example.com/v1/shape",
      params: {
        table: "todos",
      },
    },
    getKey: (item) => item.id,
    schema: todoSchema,
  })
)

```

```
import { createCollection } from "@tanstack/react-db"
import { electricCollectionOptions } from "@tanstack/electric-db-collection"

export const todoCollection = createCollection(
  electricCollectionOptions({
    id: "todos",
    shapeOptions: {
      url: "https://example.com/v1/shape",
      params: {
        table: "todos",
      },
    },
    getKey: (item) => item.id,
    schema: todoSchema,
  })
)

```

The Electric collection requires two Electric-specific options:

- shapeOptions â€” the Electric [ShapeStreamOptions](https://electric-sql.com/docs/api/clients/typescript#options) that define the [Shape](https://electric-sql.com/docs/guides/shapes) to sync into the collection; this includes the
  - url to your sync engine; and
  - params to specify the table to sync and any optional where clauses, etc.
- getKey â€” identifies the id for the rows being synced into the collection

A new collections doesn't start syncing until you call collection.preload() or you query it.

Electric shapes allow you to filter data using where clauses:

ts

```
export const myPendingTodos = createCollection(
  electricCollectionOptions({
    id: "todos",
    shapeOptions: {
      url: "https://example.com/v1/shape",
      params: {
        table: "todos",
        where: `
        status = 'pending'
        AND
        user_id = '${user.id}'
      `,
      },
    },
    getKey: (item) => item.id,
    schema: todoSchema,
  })
)

```

```
export const myPendingTodos = createCollection(
  electricCollectionOptions({
    id: "todos",
    shapeOptions: {
      url: "https://example.com/v1/shape",
      params: {
        table: "todos",
        where: `
        status = 'pending'
        AND
        user_id = '${user.id}'
      `,
      },
    },
    getKey: (item) => item.id,
    schema: todoSchema,
  })
)

```

Tip

Shape where clauses, used to filter the data you sync into ElectricCollections, are different from the [live queries](https://tanstack.com/db/latest/docs/overview#live-queries) you use to query data in components.

Live queries are much more expressive than shapes, allowing you to query across collections, join, aggregate, etc. Shapes just contain filtered database tables and are used to populate the data in a collection.

If you need more control over what data syncs into the collection, Electric allows you to [use your API](https://electric-sql.com/blog/2024/11/21/local-first-with-your-existing-api#filtering) as a proxy to both authorize and filter data.

See the [Electric docs](https://electric-sql.com/docs/intro) for more information.

[**TrailBaseCollection**](https://tanstack.com/db/latest/docs/overview#trailbasecollection)

[TrailBase](https://trailbase.io/) is an easy-to-self-host, single-executable application backend with built-in SQLite, a V8 JS runtime, auth, admin UIs and sync functionality.

TrailBase lets you expose tables via [Record APIs](https://trailbase.io/documentation/apis_record/) and subscribe to changes when enable\_subscriptions is set. Use trailBaseCollectionOptions to sync records into a collection:

ts

```
import { createCollection } from "@tanstack/react-db"
import { trailBaseCollectionOptions } from "@tanstack/trailbase-db-collection"
import { initClient } from "trailbase"

const trailBaseClient = initClient(`https://trailbase.io`)

export const todoCollection = createCollection<SelectTodo, Todo>(
  electricCollectionOptions({
    id: "todos",
    recordApi: trailBaseClient.records(`todos`),
    getKey: (item) => item.id,
    schema: todoSchema,
    parse: {
      created_at: (ts) => new Date(ts * 1000),
    },
    serialize: {
      created_at: (date) => Math.floor(date.valueOf() / 1000),
    },
  })
)

```

```
import { createCollection } from "@tanstack/react-db"
import { trailBaseCollectionOptions } from "@tanstack/trailbase-db-collection"
import { initClient } from "trailbase"

const trailBaseClient = initClient(`https://trailbase.io`)

export const todoCollection = createCollection<SelectTodo, Todo>(
  electricCollectionOptions({
    id: "todos",
    recordApi: trailBaseClient.records(`todos`),
    getKey: (item) => item.id,
    schema: todoSchema,
    parse: {
      created_at: (ts) => new Date(ts * 1000),
    },
    serialize: {
      created_at: (date) => Math.floor(date.valueOf() / 1000),
    },
  })
)

```

This collection requires the following TrailBase-specific options:

- recordApi â€” identifies the API to sync.
- getKey â€” identifies the id for the records being synced into the collection.
- parse â€” maps (v: Todo\[k\]) => SelectTodo\[k\].
- serialize â€” maps (v: SelectTodo\[k\]) => Todo\[k\].

A new collections doesn't start syncing until you call collection.preload() or you query it.

[**LocalStorageCollection**](https://tanstack.com/db/latest/docs/overview#localstoragecollection)

localStorage collections store small amounts of local-only state that persists across browser sessions and syncs across browser tabs in real-time. All data is stored under a single localStorage key and automatically synchronized using storage events.

Use localStorageCollectionOptions to create a collection that stores data in localStorage:

ts

```
import { createCollection } from "@tanstack/react-db"
import { localStorageCollectionOptions } from "@tanstack/react-db"

export const userPreferencesCollection = createCollection(
  localStorageCollectionOptions({
    id: "user-preferences",
    storageKey: "app-user-prefs", // localStorage key
    getKey: (item) => item.id,
    schema: userPrefsSchema,
  })
)

```

```
import { createCollection } from "@tanstack/react-db"
import { localStorageCollectionOptions } from "@tanstack/react-db"

export const userPreferencesCollection = createCollection(
  localStorageCollectionOptions({
    id: "user-preferences",
    storageKey: "app-user-prefs", // localStorage key
    getKey: (item) => item.id,
    schema: userPrefsSchema,
  })
)

```

The localStorage collection requires:

- storageKey â€” the localStorage key where all collection data is stored
- getKey â€” identifies the id for items in the collection

Mutation handlers (onInsert, onUpdate, onDelete) are completely optional. Data will persist to localStorage whether or not you provide handlers. You can provide alternative storage backends like sessionStorage or custom implementations that match the localStorage API.

ts

```
export const sessionCollection = createCollection(
  localStorageCollectionOptions({
    id: "session-data",
    storageKey: "session-key",
    storage: sessionStorage, // Use sessionStorage instead
    getKey: (item) => item.id,
  })
)

```

```
export const sessionCollection = createCollection(
  localStorageCollectionOptions({
    id: "session-data",
    storageKey: "session-key",
    storage: sessionStorage, // Use sessionStorage instead
    getKey: (item) => item.id,
  })
)

```

Tip

localStorage collections are perfect for user preferences, UI state, and other data that should persist locally but doesn't need server synchronization. For server-synchronized data, use [QueryCollection](https://tanstack.com/db/latest/docs/overview#querycollection) or [ElectricCollection](https://tanstack.com/db/latest/docs/overview#electriccollection) instead.

[**LocalOnlyCollection**](https://tanstack.com/db/latest/docs/overview#localonlycollection)

LocalOnly collections are designed for in-memory client data or UI state that doesn't need to persist across browser sessions or sync across tabs. They provide a simple way to manage temporary, session-only data with full optimistic mutation support.

Use localOnlyCollectionOptions to create a collection that stores data only in memory:

ts

```
import { createCollection } from "@tanstack/react-db"
import { localOnlyCollectionOptions } from "@tanstack/react-db"

export const uiStateCollection = createCollection(
  localOnlyCollectionOptions({
    id: "ui-state",
    getKey: (item) => item.id,
    schema: uiStateSchema,
    // Optional initial data to populate the collection
    initialData: [\
      { id: "sidebar", isOpen: false },\
      { id: "theme", mode: "light" },\
    ],
  })
)

```

```
import { createCollection } from "@tanstack/react-db"
import { localOnlyCollectionOptions } from "@tanstack/react-db"

export const uiStateCollection = createCollection(
  localOnlyCollectionOptions({
    id: "ui-state",
    getKey: (item) => item.id,
    schema: uiStateSchema,
    // Optional initial data to populate the collection
    initialData: [\
      { id: "sidebar", isOpen: false },\
      { id: "theme", mode: "light" },\
    ],
  })
)

```

The LocalOnly collection requires:

- getKey â€” identifies the id for items in the collection

Optional configuration:

- initialData â€” array of items to populate the collection with on creation
- onInsert, onUpdate, onDelete â€” optional mutation handlers for custom logic

Mutation handlers are completely optional. When provided, they are called before the optimistic state is confirmed. The collection automatically manages the transition from optimistic to confirmed state internally.

ts

```
export const tempDataCollection = createCollection(
  localOnlyCollectionOptions({
    id: "temp-data",
    getKey: (item) => item.id,
    onInsert: async ({ transaction }) => {
      // Custom logic before confirming the insert
      console.log("Inserting:", transaction.mutations[0].modified)
    },
    onUpdate: async ({ transaction }) => {
      // Custom logic before confirming the update
      const { original, modified } = transaction.mutations[0]
      console.log("Updating from", original, "to", modified)
    },
  })
)

```

```
export const tempDataCollection = createCollection(
  localOnlyCollectionOptions({
    id: "temp-data",
    getKey: (item) => item.id,
    onInsert: async ({ transaction }) => {
      // Custom logic before confirming the insert
      console.log("Inserting:", transaction.mutations[0].modified)
    },
    onUpdate: async ({ transaction }) => {
      // Custom logic before confirming the update
      const { original, modified } = transaction.mutations[0]
      console.log("Updating from", original, "to", modified)
    },
  })
)

```

Tip

LocalOnly collections are perfect for temporary UI state, form data, or any client-side data that doesn't need persistence. For data that should persist across sessions, use [LocalStorageCollection](https://tanstack.com/db/latest/docs/overview#localstoragecollection) instead.

[**Derived collections**](https://tanstack.com/db/latest/docs/overview#derived-collections)

Live queries return collections. This allows you to derive collections from other collections.

For example:

ts

```
import { createLiveQueryCollection, eq } from "@tanstack/db"

// Imagine you have a collection of todos.
const todoCollection = createCollection({
  // config
})

// You can derive a new collection that's a subset of it.
const completedTodoCollection = createLiveQueryCollection({
  startSync: true,
  query: (q) =>
    q.from({ todo: todoCollection }).where(({ todo }) => todo.completed),
})

```

```
import { createLiveQueryCollection, eq } from "@tanstack/db"

// Imagine you have a collection of todos.
const todoCollection = createCollection({
  // config
})

// You can derive a new collection that's a subset of it.
const completedTodoCollection = createLiveQueryCollection({
  startSync: true,
  query: (q) =>
    q.from({ todo: todoCollection }).where(({ todo }) => todo.completed),
})

```

This also works with joins to derive collections from multiple source collections. And it works recursively -- you can derive collections from other derived collections. Changes propagate efficiently using differential dataflow and it's collections all the way down.

[**Collection**](https://tanstack.com/db/latest/docs/overview#collection)

There is a Collection interface in [../packages/db/src/collection.ts](https://tanstack.com/db/latest/docs/packages/db/src/collection.ts). You can use this to implement your own collection types.

See the existing implementations in [../packages/db](https://tanstack.com/db/latest/docs/packages/db), [../packages/query-db-collection](https://tanstack.com/db/latest/docs/packages/query-db-collection), [../packages/electric-db-collection](https://tanstack.com/db/latest/docs/packages/electric-db-collection) and [../packages/trailbase-db-collection](https://tanstack.com/db/latest/docs/packages/trailbase-db-collection) for reference.

[**Live queries**](https://tanstack.com/db/latest/docs/overview#live-queries) [**useLiveQuery hook**](https://tanstack.com/db/latest/docs/overview#uselivequery-hook)

Use the useLiveQuery hook to assign live query results to a state variable in your React components:

ts

```
import { useLiveQuery } from '@tanstack/react-db'
import { eq } from '@tanstack/db'

const Todos = () => {
  const { data: todos } = useLiveQuery((q) =>
    q
      .from({ todo: todoCollection })
      .where(({ todo }) => eq(todo.completed, false))
      .orderBy(({ todo }) => todo.created_at, 'asc')
      .select(({ todo }) => ({
        id: todo.id,
        text: todo.text
      }))
  )

  return <List items={ todos } />
}

```

```
import { useLiveQuery } from '@tanstack/react-db'
import { eq } from '@tanstack/db'

const Todos = () => {
  const { data: todos } = useLiveQuery((q) =>
    q
      .from({ todo: todoCollection })
      .where(({ todo }) => eq(todo.completed, false))
      .orderBy(({ todo }) => todo.created_at, 'asc')
      .select(({ todo }) => ({
        id: todo.id,
        text: todo.text
      }))
  )

  return <List items={ todos } />
}

```

You can also query across collections with joins:

ts

```
import { useLiveQuery } from '@tanstack/react-db'
import { eq } from '@tanstack/db'

const Todos = () => {
  const { data: todos } = useLiveQuery((q) =>
    q
      .from({ todos: todoCollection })
      .join(
        { lists: listCollection },
        ({ todos, lists }) => eq(lists.id, todos.listId),
        'inner'
      )
      .where(({ lists }) => eq(lists.active, true))
      .select(({ todos, lists }) => ({
        id: todos.id,
        title: todos.title,
        listName: lists.name
      }))
  )

  return <List items={ todos } />
}

```

```
import { useLiveQuery } from '@tanstack/react-db'
import { eq } from '@tanstack/db'

const Todos = () => {
  const { data: todos } = useLiveQuery((q) =>
    q
      .from({ todos: todoCollection })
      .join(
        { lists: listCollection },
        ({ todos, lists }) => eq(lists.id, todos.listId),
        'inner'
      )
      .where(({ lists }) => eq(lists.active, true))
      .select(({ todos, lists }) => ({
        id: todos.id,
        title: todos.title,
        listName: lists.name
      }))
  )

  return <List items={ todos } />
}

```

[**queryBuilder**](https://tanstack.com/db/latest/docs/overview#querybuilder)

You can also build queries directly (outside of the component lifecycle) using the underlying queryBuilder API:

ts

```
import { createLiveQueryCollection, eq } from "@tanstack/db"

const completedTodos = createLiveQueryCollection({
  startSync: true,
  query: (q) =>
    q
      .from({ todo: todoCollection })
      .where(({ todo }) => eq(todo.completed, true)),
})

const results = completedTodos.toArray

```

```
import { createLiveQueryCollection, eq } from "@tanstack/db"

const completedTodos = createLiveQueryCollection({
  startSync: true,
  query: (q) =>
    q
      .from({ todo: todoCollection })
      .where(({ todo }) => eq(todo.completed, true)),
})

const results = completedTodos.toArray

```

Note also that:

1. the query results [are themselves a collection](https://tanstack.com/db/latest/docs/overview#derived-collections)
2. the useLiveQuery automatically starts and stops live query subscriptions when you mount and unmount your components; if you're creating queries manually, you need to manually manage the subscription lifecycle yourself

See the [Live Queries](https://tanstack.com/db/latest/docs/overview/live-queries) documentation for more details.

[**Transactional mutators**](https://tanstack.com/db/latest/docs/overview#transactional-mutators)

Transactional mutators allow you to batch and stage local changes across collections with:

- immediate application of local optimistic updates
- flexible mutationFns to handle writes, with automatic rollbacks and management of optimistic state

[**mutationFn**](https://tanstack.com/db/latest/docs/overview#mutationfn)

Mutators are created with a mutationFn. You can define a single, generic mutationFn for your whole app. Or you can define collection or mutation specific functions.

The mutationFn is responsible for handling the local changes and processing them, usually to send them to a server or database to be stored, e.g.:

tsx

```
import type { MutationFn } from "@tanstack/react-db"

const mutationFn: MutationFn = async ({ transaction }) => {
  const response = await api.todos.create(transaction.mutations)

  if (!response.ok) {
    // Throwing an error will rollback the optimistic state.
    throw new Error(`HTTP Error: ${response.status}`)
  }

  const result = await response.json()

  // Wait for the transaction to be synced back from the server
  // before discarding the optimistic state.
  const collection: Collection = transaction.mutations[0].collection
  await collection.refetch()
}

```

```
import type { MutationFn } from "@tanstack/react-db"

const mutationFn: MutationFn = async ({ transaction }) => {
  const response = await api.todos.create(transaction.mutations)

  if (!response.ok) {
    // Throwing an error will rollback the optimistic state.
    throw new Error(`HTTP Error: ${response.status}`)
  }

  const result = await response.json()

  // Wait for the transaction to be synced back from the server
  // before discarding the optimistic state.
  const collection: Collection = transaction.mutations[0].collection
  await collection.refetch()
}

```

[**createOptimisticAction**](https://tanstack.com/db/latest/docs/overview#createoptimisticaction)

Use createOptimisticAction with your mutationFn and onMutate functions to create an action that you can use to mutate data in your components in fully custom ways:

tsx

```
import { createOptimisticAction } from "@tanstack/react-db"

// Create the `addTodo` action, passing in your `mutationFn` and `onMutate`.
const addTodo = createOptimisticAction<string>({
  onMutate: (text) => {
    // Instantly applies the local optimistic state.
    todoCollection.insert({
      id: uuid(),
      text,
      completed: false,
    })
  },
  mutationFn: async (text) => {
    // Persist the todo to your backend
    const response = await fetch("/api/todos", {
      method: "POST",
      body: JSON.stringify({ text, completed: false }),
    })
    return response.json()
  },
})

const Todo = () => {
  const handleClick = () => {
    // Triggers the onMutate and then the mutationFn
    addTodo("ðŸ”¥ Make app faster")
  }

  return <Button onClick={handleClick} />
}

```

```
import { createOptimisticAction } from "@tanstack/react-db"

// Create the `addTodo` action, passing in your `mutationFn` and `onMutate`.
const addTodo = createOptimisticAction<string>({
  onMutate: (text) => {
    // Instantly applies the local optimistic state.
    todoCollection.insert({
      id: uuid(),
      text,
      completed: false,
    })
  },
  mutationFn: async (text) => {
    // Persist the todo to your backend
    const response = await fetch("/api/todos", {
      method: "POST",
      body: JSON.stringify({ text, completed: false }),
    })
    return response.json()
  },
})

const Todo = () => {
  const handleClick = () => {
    // Triggers the onMutate and then the mutationFn
    addTodo("ðŸ”¥ Make app faster")
  }

  return <Button onClick={handleClick} />
}

```

[**Manual Transactions**](https://tanstack.com/db/latest/docs/overview#manual-transactions)

By manually creating transactions, you can fully control their lifecycles and behaviors. createOptimisticAction is a ~25 line
function which implements a common transaction pattern. Feel free to invent your own patterns!

Here's one way you could use transactions.

ts

```
import { createTransaction } from "@tanstack/react-db"

const addTodoTx = createTransaction({
  autoCommit: false,
  mutationFn: async ({ transaction }) => {
    // Persist data to backend
    await Promise.all(transaction.mutations.map(mutation => {
      return await api.saveTodo(mutation.modified)
    })
  },
})

// Apply first change
addTodoTx.mutate(() => todoCollection.insert({ id: '1', text: 'First todo', completed: false }))

// user reviews change

// Apply another change
addTodoTx.mutate(() => todoCollection.insert({ id: '2', text: 'Second todo', completed: false }))

// User decides to save and we call .commit() and the mutations are persisted to the backend.
addTodoTx.commit()

```

```
import { createTransaction } from "@tanstack/react-db"

const addTodoTx = createTransaction({
  autoCommit: false,
  mutationFn: async ({ transaction }) => {
    // Persist data to backend
    await Promise.all(transaction.mutations.map(mutation => {
      return await api.saveTodo(mutation.modified)
    })
  },
})

// Apply first change
addTodoTx.mutate(() => todoCollection.insert({ id: '1', text: 'First todo', completed: false }))

// user reviews change

// Apply another change
addTodoTx.mutate(() => todoCollection.insert({ id: '2', text: 'Second todo', completed: false }))

// User decides to save and we call .commit() and the mutations are persisted to the backend.
addTodoTx.commit()

```

[**Transaction lifecycle**](https://tanstack.com/db/latest/docs/overview#transaction-lifecycle)

Transactions progress through the following states:

1. pending: Initial state when a transaction is created and optimistic mutations can be applied
2. persisting: Transaction is being persisted to the backend
3. completed: Transaction has been successfully persisted and any backend changes have been synced back.
4. failed: An error was thrown while persisting or syncing back the Transaction

[**Write operations**](https://tanstack.com/db/latest/docs/overview#write-operations)

Collections support insert, update and delete operations.

[**insert**](https://tanstack.com/db/latest/docs/overview#insert)

typescript

```
// Insert a single item
myCollection.insert({ text: "Buy groceries", completed: false })

// Insert multiple items
insert([\
  { text: "Buy groceries", completed: false },\
  { text: "Walk dog", completed: false },\
])

// Insert with optimistic updates disabled
myCollection.insert(
  { text: "Server-validated item", completed: false },
  { optimistic: false }
)

// Insert with metadata and optimistic control
myCollection.insert(
  { text: "Custom item", completed: false },
  {
    metadata: { source: "import" },
    optimistic: true, // default behavior
  }
)

```

```
// Insert a single item
myCollection.insert({ text: "Buy groceries", completed: false })

// Insert multiple items
insert([\
  { text: "Buy groceries", completed: false },\
  { text: "Walk dog", completed: false },\
])

// Insert with optimistic updates disabled
myCollection.insert(
  { text: "Server-validated item", completed: false },
  { optimistic: false }
)

// Insert with metadata and optimistic control
myCollection.insert(
  { text: "Custom item", completed: false },
  {
    metadata: { source: "import" },
    optimistic: true, // default behavior
  }
)

```

[**update**](https://tanstack.com/db/latest/docs/overview#update)

We use a proxy to capture updates as immutable draft optimistic updates.

typescript

```
// Update a single item
update(todo.id, (draft) => {
  draft.completed = true
})

// Update multiple items
update([todo1.id, todo2.id], (drafts) => {
  drafts.forEach((draft) => {
    draft.completed = true
  })
})

// Update with metadata
update(todo.id, { metadata: { reason: "user update" } }, (draft) => {
  draft.text = "Updated text"
})

// Update without optimistic updates
update(todo.id, { optimistic: false }, (draft) => {
  draft.status = "server-validated"
})

// Update with both metadata and optimistic control
update(
  todo.id,
  {
    metadata: { reason: "admin update" },
    optimistic: false,
  },
  (draft) => {
    draft.priority = "high"
  }
)

```

```
// Update a single item
update(todo.id, (draft) => {
  draft.completed = true
})

// Update multiple items
update([todo1.id, todo2.id], (drafts) => {
  drafts.forEach((draft) => {
    draft.completed = true
  })
})

// Update with metadata
update(todo.id, { metadata: { reason: "user update" } }, (draft) => {
  draft.text = "Updated text"
})

// Update without optimistic updates
update(todo.id, { optimistic: false }, (draft) => {
  draft.status = "server-validated"
})

// Update with both metadata and optimistic control
update(
  todo.id,
  {
    metadata: { reason: "admin update" },
    optimistic: false,
  },
  (draft) => {
    draft.priority = "high"
  }
)

```

[**delete**](https://tanstack.com/db/latest/docs/overview#delete)

typescript

```
// Delete a single item
delete todo.id

// Delete multiple items
delete [todo1.id, todo2.id]

// Delete with metadata
delete (todo.id, { metadata: { reason: "completed" } })

// Delete without optimistic updates (waits for server confirmation)
delete (todo.id, { optimistic: false })

// Delete with metadata and optimistic control
delete (todo.id,
{
  metadata: { reason: "admin deletion" },
  optimistic: false,
})

```

```
// Delete a single item
delete todo.id

// Delete multiple items
delete [todo1.id, todo2.id]

// Delete with metadata
delete (todo.id, { metadata: { reason: "completed" } })

// Delete without optimistic updates (waits for server confirmation)
delete (todo.id, { optimistic: false })

// Delete with metadata and optimistic control
delete (todo.id,
{
  metadata: { reason: "admin deletion" },
  optimistic: false,
})

```

[**Controlling optimistic behavior**](https://tanstack.com/db/latest/docs/overview#controlling-optimistic-behavior)

By default, all mutations (insert, update, delete) apply optimistic updates immediately to provide instant feedback in your UI. However, there are cases where you may want to disable this behavior and wait for server confirmation before applying changes locally.

[**When to use optimistic: false**](https://tanstack.com/db/latest/docs/overview#when-to-use-optimistic-false)

Consider disabling optimistic updates when:

- **Complex server-side processing**: Inserts that depend on server-side generation (e.g., cascading foreign keys, computed fields)
- **Validation requirements**: Operations where backend validation might reject the change
- **Confirmation workflows**: Deletes where UX should wait for confirmation before removing data
- **Batch operations**: Large operations where optimistic rollback would be disruptive

[**Behavior differences**](https://tanstack.com/db/latest/docs/overview#behavior-differences)

**optimistic: true (default)**:

- Immediately applies mutation to the local store
- Provides instant UI feedback
- Requires rollback if server rejects the mutation
- Best for simple, predictable operations

**optimistic: false**:

- Does not modify local store until server confirms
- No immediate UI feedback, but no rollback needed
- UI updates only after successful server response
- Best for complex or validation-heavy operations

typescript

```
// Example: Critical deletion that needs confirmation
const handleDeleteAccount = () => {
  // Don't remove from UI until server confirms
  userCollection.delete(userId, { optimistic: false })
}

// Example: Server-generated data
const handleCreateInvoice = () => {
  // Server generates invoice number, tax calculations, etc.
  invoiceCollection.insert(invoiceData, { optimistic: false })
}

// Example: Mixed approach in same transaction
tx.mutate(() => {
  // Instant UI feedback for simple change
  todoCollection.update(todoId, (draft) => {
    draft.completed = true
  })

  // Wait for server confirmation for complex change
  auditCollection.insert(auditRecord, { optimistic: false })
})

```

```
// Example: Critical deletion that needs confirmation
const handleDeleteAccount = () => {
  // Don't remove from UI until server confirms
  userCollection.delete(userId, { optimistic: false })
}

// Example: Server-generated data
const handleCreateInvoice = () => {
  // Server generates invoice number, tax calculations, etc.
  invoiceCollection.insert(invoiceData, { optimistic: false })
}

// Example: Mixed approach in same transaction
tx.mutate(() => {
  // Instant UI feedback for simple change
  todoCollection.update(todoId, (draft) => {
    draft.completed = true
  })

  // Wait for server confirmation for complex change
  auditCollection.insert(auditRecord, { optimistic: false })
})

```

[**Usage examples**](https://tanstack.com/db/latest/docs/overview#usage-examples)

Here we illustrate two common ways of using TanStack DB:

1. [using TanStack Query](https://tanstack.com/db/latest/docs/overview#1-tanstack-query) with an existing REST API
2. [using the ElectricSQL sync engine](https://tanstack.com/db/latest/docs/overview#2-electricsql-sync) with a generic ingestion endpoint

Tip

You can combine these patterns. One of the benefits of TanStack DB is that you can integrate different ways of loading data and handling mutations into the same app. Your components don't need to know where the data came from or goes.

[**1\. TanStack Query**](https://tanstack.com/db/latest/docs/overview#1-tanstack-query)

You can use TanStack DB with your existing REST API via TanStack Query.

The steps are to:

1. create [QueryCollection](https://tanstack.com/db/latest/docs/overview#querycollection) s that load data using TanStack Query
2. implement [mutationFn](https://tanstack.com/db/latest/docs/overview#mutationfn) s that handle mutations by posting them to your API endpoints

tsx

```
import { useLiveQuery, createCollection } from "@tanstack/react-db"
import { queryCollectionOptions } from "@tanstack/electric-db-collection"

// Load data into collections using TanStack Query.
// It's common to define these in a `collections` module.
const todoCollection = createCollection(queryCollectionOptions({
  queryKey: ["todos"],
  queryFn: async () => fetch("/api/todos"),
  getKey: (item) => item.id,
  schema: todoSchema, // any standard schema
  onInsert: ({ transaction }) => {
    const { changes: newTodo } = transaction.mutations[0]

    // Handle the local write by sending it to your API.
    await api.todos.create(newTodo)
  }
  // also add onUpdate, onDelete as needed.
}))
const listCollection = createCollection(queryCollectionOptions({
  queryKey: ["todo-lists"],
  queryFn: async () => fetch("/api/todo-lists"),
  getKey: (item) => item.id,
  schema: todoListSchema
  onInsert: ({ transaction }) => {
    const { changes: newTodo } = transaction.mutations[0]

    // Handle the local write by sending it to your API.
    await api.todoLists.create(newTodo)
  }
  // also add onUpdate, onDelete as needed.
}))

const Todos = () => {
  // Read the data using live queries. Here we show a live
  // query that joins across two collections.
  const { data: todos } = useLiveQuery((q) =>
    q
      .from({ todo: todoCollection })
      .join(
        { list: listCollection },
        ({ todo, list }) => eq(list.id, todo.list_id),
        'inner'
      )
      .where(({ list }) => eq(list.active, true))
      .select(({ todo, list }) => ({
        id: todo.id,
        text: todo.text,
        status: todo.status,
        listName: list.name
      }))
  )

  // ...

}

```

```
import { useLiveQuery, createCollection } from "@tanstack/react-db"
import { queryCollectionOptions } from "@tanstack/electric-db-collection"

// Load data into collections using TanStack Query.
// It's common to define these in a `collections` module.
const todoCollection = createCollection(queryCollectionOptions({
  queryKey: ["todos"],
  queryFn: async () => fetch("/api/todos"),
  getKey: (item) => item.id,
  schema: todoSchema, // any standard schema
  onInsert: ({ transaction }) => {
    const { changes: newTodo } = transaction.mutations[0]

    // Handle the local write by sending it to your API.
    await api.todos.create(newTodo)
  }
  // also add onUpdate, onDelete as needed.
}))
const listCollection = createCollection(queryCollectionOptions({
  queryKey: ["todo-lists"],
  queryFn: async () => fetch("/api/todo-lists"),
  getKey: (item) => item.id,
  schema: todoListSchema
  onInsert: ({ transaction }) => {
    const { changes: newTodo } = transaction.mutations[0]

    // Handle the local write by sending it to your API.
    await api.todoLists.create(newTodo)
  }
  // also add onUpdate, onDelete as needed.
}))

const Todos = () => {
  // Read the data using live queries. Here we show a live
  // query that joins across two collections.
  const { data: todos } = useLiveQuery((q) =>
    q
      .from({ todo: todoCollection })
      .join(
        { list: listCollection },
        ({ todo, list }) => eq(list.id, todo.list_id),
        'inner'
      )
      .where(({ list }) => eq(list.active, true))
      .select(({ todo, list }) => ({
        id: todo.id,
        text: todo.text,
        status: todo.status,
        listName: list.name
      }))
  )

  // ...

}

```

This pattern allows you to extend an existing TanStack Query application, or any application built on a REST API, with blazing fast, cross-collection live queries and local optimistic mutations with automatically managed optimistic state.

[**2\. ElectricSQL sync**](https://tanstack.com/db/latest/docs/overview#2-electricsql-sync)

One of the most powerful ways of using TanStack DB is with a sync engine, for a fully local-first experience with real-time sync. This allows you to incrementally adopt sync into an existing app, whilst still handling writes with your existing API.

Here, we illustrate this pattern using [ElectricSQL](https://electric-sql.com/) as the sync engine.

tsx

```
import type { Collection } from '@tanstack/db'
import type { MutationFn, PendingMutation, createCollection } from '@tanstack/react-db'
import { electricCollectionOptions } from '@tanstack/electric-db-collection'

export const todoCollection = createCollection(electricCollectionOptions({
  id: 'todos',
  schema: todoSchema,
  // Electric syncs data using "shapes". These are filtered views
  // on database tables that Electric keeps in sync for you.
  shapeOptions: {
    url: 'https://api.electric-sql.cloud/v1/shape',
    params: {
      table: 'todos'
    }
  },
  getKey: (item) => item.id,
  schema: todoSchema
  onInsert: ({ transaction }) => {
    const response = await api.todos.create(transaction.mutations[0].modified)

    return { txid: response.txid}
  }
  // You can also implement onUpdate, onDelete as needed.
}))

const AddTodo = () => {
  return (
    <Button
      onClick={() =>
        todoCollection.insert({ text: "ðŸ”¥ Make app faster" })
      }
    />
  )
}

```

```
import type { Collection } from '@tanstack/db'
import type { MutationFn, PendingMutation, createCollection } from '@tanstack/react-db'
import { electricCollectionOptions } from '@tanstack/electric-db-collection'

export const todoCollection = createCollection(electricCollectionOptions({
  id: 'todos',
  schema: todoSchema,
  // Electric syncs data using "shapes". These are filtered views
  // on database tables that Electric keeps in sync for you.
  shapeOptions: {
    url: 'https://api.electric-sql.cloud/v1/shape',
    params: {
      table: 'todos'
    }
  },
  getKey: (item) => item.id,
  schema: todoSchema
  onInsert: ({ transaction }) => {
    const response = await api.todos.create(transaction.mutations[0].modified)

    return { txid: response.txid}
  }
  // You can also implement onUpdate, onDelete as needed.
}))

const AddTodo = () => {
  return (
    <Button
      onClick={() =>
        todoCollection.insert({ text: "ðŸ”¥ Make app faster" })
      }
    />
  )
}

# createTransaction

[**Function: createTransaction()**](https://tanstack.com/db/latest/docs/reference/functions/createtransaction#function-createtransaction)

ts

```
function createTransaction<T>(config): Transaction<T>

```

```
function createTransaction<T>(config): Transaction<T>

```

Defined in: [packages/db/src/transactions.ts:74](https://github.com/TanStack/db/blob/main/packages/db/src/transactions.ts#L74)

Creates a new transaction for grouping multiple collection operations

[**Type Parameters**](https://tanstack.com/db/latest/docs/reference/functions/createtransaction#type-parameters)

â€¢ **T** _extends_ object = Record<string, unknown>

[**Parameters**](https://tanstack.com/db/latest/docs/reference/functions/createtransaction#parameters) [**config**](https://tanstack.com/db/latest/docs/reference/functions/createtransaction#config)

[TransactionConfig](https://tanstack.com/db/latest/docs/reference/interfaces/transactionconfig) <T>

Transaction configuration with mutation function

[**Returns**](https://tanstack.com/db/latest/docs/reference/functions/createtransaction#returns)

[Transaction](https://tanstack.com/db/latest/docs/reference/classes/transaction) <T>

A new Transaction instance

[**Examples**](https://tanstack.com/db/latest/docs/reference/functions/createtransaction#examples)

ts

```
// Basic transaction usage
const tx = createTransaction({
  mutationFn: async ({ transaction }) => {
    // Send all mutations to API
    await api.saveChanges(transaction.mutations)
  }
})

tx.mutate(() => {
  collection.insert({ id: "1", text: "Buy milk" })
  collection.update("2", draft => { draft.completed = true })
})

await tx.isPersisted.promise

```

```
// Basic transaction usage
const tx = createTransaction({
  mutationFn: async ({ transaction }) => {
    // Send all mutations to API
    await api.saveChanges(transaction.mutations)
  }
})

tx.mutate(() => {
  collection.insert({ id: "1", text: "Buy milk" })
  collection.update("2", draft => { draft.completed = true })
})

await tx.isPersisted.promise

```

ts

```
// Handle transaction errors
try {
  const tx = createTransaction({
    mutationFn: async () => { throw new Error("API failed") }
  })

  tx.mutate(() => {
    collection.insert({ id: "1", text: "New item" })
  })

  await tx.isPersisted.promise
} catch (error) {
  console.log('Transaction failed:', error)
}

```

```
// Handle transaction errors
try {
  const tx = createTransaction({
    mutationFn: async () => { throw new Error("API failed") }
  })

  tx.mutate(() => {
    collection.insert({ id: "1", text: "New item" })
  })

  await tx.isPersisted.promise
} catch (error) {
  console.log('Transaction failed:', error)
}

```

ts

```
// Manual commit control
const tx = createTransaction({
  autoCommit: false,
  mutationFn: async () => {
    // API call
  }
})

tx.mutate(() => {
  collection.insert({ id: "1", text: "Item" })
})

// Commit later
await tx.commit()

```

```
// Manual commit control
const tx = createTransaction({
  autoCommit: false,
  mutationFn: async () => {
    // API call
  }
})

tx.mutate(() => {
  collection.insert({ id: "1", text: "Item" })
})

// Commit later
await tx.commit()

```
# useLiveQuery

[**Function: useLiveQuery()**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#function-uselivequery) [**Call Signature**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#call-signature)

ts

```
function useLiveQuery<TContext>(queryFn, deps?): object

```

```
function useLiveQuery<TContext>(queryFn, deps?): object

```

Defined in: [useLiveQuery.ts:64](https://github.com/TanStack/db/blob/main/packages/react-db/src/useLiveQuery.ts#L64)

Create a live query using a query function

[**Type Parameters**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#type-parameters)

â€¢ **TContext** _extends_ Context

[**Parameters**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#parameters) [**queryFn**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#queryfn)

(q) =\> QueryBuilder<TContext>

Query function that defines what data to fetch

[**deps?**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#deps)

unknown\[\]

Array of dependencies that trigger query re-execution when changed

[**Returns**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#returns)

object

Object with reactive data, state, and status information

[**collection**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#collection)

ts

```
collection: Collection<{ [K in string | number | symbol]: (TContext["result"] extends object ? any[any] : TContext["hasJoins"] extends true ? TContext["schema"] : TContext["schema"][TContext["fromSourceName"]])[K] }, string | number, {}>;

```

```
collection: Collection<{ [K in string | number | symbol]: (TContext["result"] extends object ? any[any] : TContext["hasJoins"] extends true ? TContext["schema"] : TContext["schema"][TContext["fromSourceName"]])[K] }, string | number, {}>;

```

[**data**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#data)

ts

```
data: { [K in string | number | symbol]: (TContext["result"] extends object ? any[any] : TContext["hasJoins"] extends true ? TContext["schema"] : TContext["schema"][TContext["fromSourceName"]])[K] }[];

```

```
data: { [K in string | number | symbol]: (TContext["result"] extends object ? any[any] : TContext["hasJoins"] extends true ? TContext["schema"] : TContext["schema"][TContext["fromSourceName"]])[K] }[];

```

[**isCleanedUp**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#iscleanedup)

ts

```
isCleanedUp: boolean;

```

```
isCleanedUp: boolean;

```

[**isError**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#iserror)

ts

```
isError: boolean;

```

```
isError: boolean;

```

[**isIdle**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#isidle)

ts

```
isIdle: boolean;

```

```
isIdle: boolean;

```

[**isLoading**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#isloading)

ts

```
isLoading: boolean;

```

```
isLoading: boolean;

```

[**isReady**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#isready)

ts

```
isReady: boolean;

```

```
isReady: boolean;

```

[**state**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#state)

ts

```
state: Map<string | number, { [K in string | number | symbol]: (TContext["result"] extends object ? any[any] : TContext["hasJoins"] extends true ? TContext["schema"] : TContext["schema"][TContext["fromSourceName"]])[K] }>;

```

```
state: Map<string | number, { [K in string | number | symbol]: (TContext["result"] extends object ? any[any] : TContext["hasJoins"] extends true ? TContext["schema"] : TContext["schema"][TContext["fromSourceName"]])[K] }>;

```

[**status**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#status)

ts

```
status: CollectionStatus;

```

```
status: CollectionStatus;

```

[**Examples**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#examples)

ts

```
// Basic query with object syntax
const { data, isLoading } = useLiveQuery((q) =>
  q.from({ todos: todosCollection })
   .where(({ todos }) => eq(todos.completed, false))
   .select(({ todos }) => ({ id: todos.id, text: todos.text }))
)

```

```
// Basic query with object syntax
const { data, isLoading } = useLiveQuery((q) =>
  q.from({ todos: todosCollection })
   .where(({ todos }) => eq(todos.completed, false))
   .select(({ todos }) => ({ id: todos.id, text: todos.text }))
)

```

ts

```
// With dependencies that trigger re-execution
const { data, state } = useLiveQuery(
  (q) => q.from({ todos: todosCollection })
         .where(({ todos }) => gt(todos.priority, minPriority)),
  [minPriority] // Re-run when minPriority changes
)

```

```
// With dependencies that trigger re-execution
const { data, state } = useLiveQuery(
  (q) => q.from({ todos: todosCollection })
         .where(({ todos }) => gt(todos.priority, minPriority)),
  [minPriority] // Re-run when minPriority changes
)

```

ts

```
// Join pattern
const { data } = useLiveQuery((q) =>
  q.from({ issues: issueCollection })
   .join({ persons: personCollection }, ({ issues, persons }) =>
     eq(issues.userId, persons.id)
   )
   .select(({ issues, persons }) => ({
     id: issues.id,
     title: issues.title,
     userName: persons.name
   }))
)

```

```
// Join pattern
const { data } = useLiveQuery((q) =>
  q.from({ issues: issueCollection })
   .join({ persons: personCollection }, ({ issues, persons }) =>
     eq(issues.userId, persons.id)
   )
   .select(({ issues, persons }) => ({
     id: issues.id,
     title: issues.title,
     userName: persons.name
   }))
)

```

ts

```
// Handle loading and error states
const { data, isLoading, isError, status } = useLiveQuery((q) =>
  q.from({ todos: todoCollection })
)

if (isLoading) return <div>Loading...</div>
if (isError) return <div>Error: {status}</div>

return (
  <ul>
    {data.map(todo => <li key={todo.id}>{todo.text}</li>)}
  </ul>
)

```

```
// Handle loading and error states
const { data, isLoading, isError, status } = useLiveQuery((q) =>
  q.from({ todos: todoCollection })
)

if (isLoading) return <div>Loading...</div>
if (isError) return <div>Error: {status}</div>

return (
  <ul>
    {data.map(todo => <li key={todo.id}>{todo.text}</li>)}
  </ul>
)

```

[**Call Signature**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#call-signature-1)

ts

```
function useLiveQuery<TContext>(config, deps?): object

```

```
function useLiveQuery<TContext>(config, deps?): object

```

Defined in: [useLiveQuery.ts:113](https://github.com/TanStack/db/blob/main/packages/react-db/src/useLiveQuery.ts#L113)

Create a live query using configuration object

[**Type Parameters**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#type-parameters-1)

â€¢ **TContext** _extends_ Context

[**Parameters**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#parameters-1) [**config**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#config)

LiveQueryCollectionConfig<TContext>

Configuration object with query and options

[**deps?**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#deps-1)

unknown\[\]

Array of dependencies that trigger query re-execution when changed

[**Returns**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#returns-1)

object

Object with reactive data, state, and status information

[**collection**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#collection-1)

ts

```
collection: Collection<{ [K in string | number | symbol]: (TContext["result"] extends object ? any[any] : TContext["hasJoins"] extends true ? TContext["schema"] : TContext["schema"][TContext["fromSourceName"]])[K] }, string | number, {}>;

```

```
collection: Collection<{ [K in string | number | symbol]: (TContext["result"] extends object ? any[any] : TContext["hasJoins"] extends true ? TContext["schema"] : TContext["schema"][TContext["fromSourceName"]])[K] }, string | number, {}>;

```

[**data**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#data-1)

ts

```
data: { [K in string | number | symbol]: (TContext["result"] extends object ? any[any] : TContext["hasJoins"] extends true ? TContext["schema"] : TContext["schema"][TContext["fromSourceName"]])[K] }[];

```

```
data: { [K in string | number | symbol]: (TContext["result"] extends object ? any[any] : TContext["hasJoins"] extends true ? TContext["schema"] : TContext["schema"][TContext["fromSourceName"]])[K] }[];

```

[**isCleanedUp**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#iscleanedup-1)

ts

```
isCleanedUp: boolean;

```

```
isCleanedUp: boolean;

```

[**isError**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#iserror-1)

ts

```
isError: boolean;

```

```
isError: boolean;

```

[**isIdle**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#isidle-1)

ts

```
isIdle: boolean;

```

```
isIdle: boolean;

```

[**isLoading**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#isloading-1)

ts

```
isLoading: boolean;

```

```
isLoading: boolean;

```

[**isReady**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#isready-1)

ts

```
isReady: boolean;

```

```
isReady: boolean;

```

[**state**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#state-1)

ts

```
state: Map<string | number, { [K in string | number | symbol]: (TContext["result"] extends object ? any[any] : TContext["hasJoins"] extends true ? TContext["schema"] : TContext["schema"][TContext["fromSourceName"]])[K] }>;

```

```
state: Map<string | number, { [K in string | number | symbol]: (TContext["result"] extends object ? any[any] : TContext["hasJoins"] extends true ? TContext["schema"] : TContext["schema"][TContext["fromSourceName"]])[K] }>;

```

[**status**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#status-1)

ts

```
status: CollectionStatus;

```

```
status: CollectionStatus;

```

[**Examples**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#examples-1)

ts

```
// Basic config object usage
const { data, status } = useLiveQuery({
  query: (q) => q.from({ todos: todosCollection }),
  gcTime: 60000
})

```

```
// Basic config object usage
const { data, status } = useLiveQuery({
  query: (q) => q.from({ todos: todosCollection }),
  gcTime: 60000
})

```

ts

```
// With query builder and options
const queryBuilder = new Query()
  .from({ persons: collection })
  .where(({ persons }) => gt(persons.age, 30))
  .select(({ persons }) => ({ id: persons.id, name: persons.name }))

const { data, isReady } = useLiveQuery({ query: queryBuilder })

```

```
// With query builder and options
const queryBuilder = new Query()
  .from({ persons: collection })
  .where(({ persons }) => gt(persons.age, 30))
  .select(({ persons }) => ({ id: persons.id, name: persons.name }))

const { data, isReady } = useLiveQuery({ query: queryBuilder })

```

ts

```
// Handle all states uniformly
const { data, isLoading, isReady, isError } = useLiveQuery({
  query: (q) => q.from({ items: itemCollection })
})

if (isLoading) return <div>Loading...</div>
if (isError) return <div>Something went wrong</div>
if (!isReady) return <div>Preparing...</div>

return <div>{data.length} items loaded</div>

```

```
// Handle all states uniformly
const { data, isLoading, isReady, isError } = useLiveQuery({
  query: (q) => q.from({ items: itemCollection })
})

if (isLoading) return <div>Loading...</div>
if (isError) return <div>Something went wrong</div>
if (!isReady) return <div>Preparing...</div>

return <div>{data.length} items loaded</div>

```

[**Call Signature**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#call-signature-2)

ts

```
function useLiveQuery<TResult, TKey, TUtils>(liveQueryCollection): object

```

```
function useLiveQuery<TResult, TKey, TUtils>(liveQueryCollection): object

```

Defined in: [useLiveQuery.ts:158](https://github.com/TanStack/db/blob/main/packages/react-db/src/useLiveQuery.ts#L158)

Subscribe to an existing live query collection

[**Type Parameters**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#type-parameters-2)

â€¢ **TResult** _extends_ object

â€¢ **TKey** _extends_ string \| number

â€¢ **TUtils** _extends_ Record<string, any>

[**Parameters**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#parameters-2) [**liveQueryCollection**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#livequerycollection)

Collection<TResult, TKey, TUtils>

Pre-created live query collection to subscribe to

[**Returns**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#returns-2)

object

Object with reactive data, state, and status information

[**collection**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#collection-2)

ts

```
collection: Collection<TResult, TKey, TUtils>;

```

```
collection: Collection<TResult, TKey, TUtils>;

```

[**data**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#data-2)

ts

```
data: TResult[];

```

```
data: TResult[];

```

[**isCleanedUp**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#iscleanedup-2)

ts

```
isCleanedUp: boolean;

```

```
isCleanedUp: boolean;

```

[**isError**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#iserror-2)

ts

```
isError: boolean;

```

```
isError: boolean;

```

[**isIdle**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#isidle-2)

ts

```
isIdle: boolean;

```

```
isIdle: boolean;

```

[**isLoading**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#isloading-2)

ts

```
isLoading: boolean;

```

```
isLoading: boolean;

```

[**isReady**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#isready-2)

ts

```
isReady: boolean;

```

```
isReady: boolean;

```

[**state**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#state-2)

ts

```
state: Map<TKey, TResult>;

```

```
state: Map<TKey, TResult>;

```

[**status**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#status-2)

ts

```
status: CollectionStatus;

```

```
status: CollectionStatus;

```

[**Examples**](https://tanstack.com/db/latest/docs/framework/react/reference/functions/uselivequery#examples-2)

ts

```
// Using pre-created live query collection
const myLiveQuery = createLiveQueryCollection((q) =>
  q.from({ todos: todosCollection }).where(({ todos }) => eq(todos.active, true))
)
const { data, collection } = useLiveQuery(myLiveQuery)

```

```
// Using pre-created live query collection
const myLiveQuery = createLiveQueryCollection((q) =>
  q.from({ todos: todosCollection }).where(({ todos }) => eq(todos.active, true))
)
const { data, collection } = useLiveQuery(myLiveQuery)

```

ts

```
// Access collection methods directly
const { data, collection, isReady } = useLiveQuery(existingCollection)

// Use collection for mutations
const handleToggle = (id) => {
  collection.update(id, draft => { draft.completed = !draft.completed })
}

```

```
// Access collection methods directly
const { data, collection, isReady } = useLiveQuery(existingCollection)

// Use collection for mutations
const handleToggle = (id) => {
  collection.update(id, draft => { draft.completed = !draft.completed })
}

```

ts

```
// Handle states consistently
const { data, isLoading, isError } = useLiveQuery(sharedCollection)

if (isLoading) return <div>Loading...</div>
if (isError) return <div>Error loading data</div>

return <div>{data.map(item => <Item key={item.id} {...item} />)}</div>

```

```
// Handle states consistently
const { data, isLoading, isError } = useLiveQuery(sharedCollection)

if (isLoading) return <div>Loading...</div>
if (isError) return <div>Error loading data</div>

return <div>{data.map(item => <Item key={item.id} {...item} />)}</div>

``

# Query Collection

[**Query Collection**](https://tanstack.com/db/latest/docs/collections/query-collection#query-collection)

Query collections provide seamless integration between TanStack DB and TanStack Query, enabling automatic synchronization between your local database and remote data sources.

[**Overview**](https://tanstack.com/db/latest/docs/collections/query-collection#overview)

The @tanstack/query-db-collection package allows you to create collections that:

- Automatically sync with remote data via TanStack Query
- Support optimistic updates with automatic rollback on errors
- Handle persistence through customizable mutation handlers
- Provide direct write capabilities as an escape hatch for advanced scenarios

[**Installation**](https://tanstack.com/db/latest/docs/collections/query-collection#installation)

bash

```
npm install @tanstack/query-db-collection @tanstack/query-core @tanstack/db

```

```
npm install @tanstack/query-db-collection @tanstack/query-core @tanstack/db

```

[**Basic Usage**](https://tanstack.com/db/latest/docs/collections/query-collection#basic-usage)

typescript

```
import { QueryClient } from '@tanstack/query-core'
import { createCollection } from '@tanstack/db'
import { queryCollectionOptions } from '@tanstack/query-db-collection'

const queryClient = new QueryClient()

const todosCollection = createCollection(
  queryCollectionOptions({
    queryKey: ['todos'],
    queryFn: async () => {
      const response = await fetch('/api/todos')
      return response.json()
    },
    queryClient,
    getKey: (item) => item.id,
  })
)

```

```
import { QueryClient } from '@tanstack/query-core'
import { createCollection } from '@tanstack/db'
import { queryCollectionOptions } from '@tanstack/query-db-collection'

const queryClient = new QueryClient()

const todosCollection = createCollection(
  queryCollectionOptions({
    queryKey: ['todos'],
    queryFn: async () => {
      const response = await fetch('/api/todos')
      return response.json()
    },
    queryClient,
    getKey: (item) => item.id,
  })
)

```

[**Configuration Options**](https://tanstack.com/db/latest/docs/collections/query-collection#configuration-options)

The queryCollectionOptions function accepts the following options:

[**Required Options**](https://tanstack.com/db/latest/docs/collections/query-collection#required-options)

- queryKey: The query key for TanStack Query
- queryFn: Function that fetches data from the server
- queryClient: TanStack Query client instance
- getKey: Function to extract the unique key from an item

[**Query Options**](https://tanstack.com/db/latest/docs/collections/query-collection#query-options)

- enabled: Whether the query should automatically run (default: true)
- refetchInterval: Refetch interval in milliseconds
- retry: Retry configuration for failed queries
- retryDelay: Delay between retries
- staleTime: How long data is considered fresh
- meta: Optional metadata that will be passed to the query function context

[**Collection Options**](https://tanstack.com/db/latest/docs/collections/query-collection#collection-options)

- id: Unique identifier for the collection
- schema: Schema for validating items
- sync: Custom sync configuration
- startSync: Whether to start syncing immediately (default: true)

[**Persistence Handlers**](https://tanstack.com/db/latest/docs/collections/query-collection#persistence-handlers)

- onInsert: Handler called before insert operations
- onUpdate: Handler called before update operations
- onDelete: Handler called before delete operations

[**Persistence Handlers**](https://tanstack.com/db/latest/docs/collections/query-collection#persistence-handlers-1)

You can define handlers that are called when mutations occur. These handlers can persist changes to your backend and control whether the query should refetch after the operation:

typescript

```
const todosCollection = createCollection(
  queryCollectionOptions({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    queryClient,
    getKey: (item) => item.id,

    onInsert: async ({ transaction }) => {
      const newItems = transaction.mutations.map(m => m.modified)
      await api.createTodos(newItems)
      // Returning nothing or { refetch: true } will trigger a refetch
      // Return { refetch: false } to skip automatic refetch
    },

    onUpdate: async ({ transaction }) => {
      const updates = transaction.mutations.map(m => ({
        id: m.key,
        changes: m.changes
      }))
      await api.updateTodos(updates)
    },

    onDelete: async ({ transaction }) => {
      const ids = transaction.mutations.map(m => m.key)
      await api.deleteTodos(ids)
    }
  })
)

```

```
const todosCollection = createCollection(
  queryCollectionOptions({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    queryClient,
    getKey: (item) => item.id,

    onInsert: async ({ transaction }) => {
      const newItems = transaction.mutations.map(m => m.modified)
      await api.createTodos(newItems)
      // Returning nothing or { refetch: true } will trigger a refetch
      // Return { refetch: false } to skip automatic refetch
    },

    onUpdate: async ({ transaction }) => {
      const updates = transaction.mutations.map(m => ({
        id: m.key,
        changes: m.changes
      }))
      await api.updateTodos(updates)
    },

    onDelete: async ({ transaction }) => {
      const ids = transaction.mutations.map(m => m.key)
      await api.deleteTodos(ids)
    }
  })
)

```

[**Controlling Refetch Behavior**](https://tanstack.com/db/latest/docs/collections/query-collection#controlling-refetch-behavior)

By default, after any persistence handler (onInsert, onUpdate, or onDelete) completes successfully, the query will automatically refetch to ensure the local state matches the server state.

You can control this behavior by returning an object with a refetch property:

typescript

```
onInsert: async ({ transaction }) => {
  await api.createTodos(transaction.mutations.map(m => m.modified))

  // Skip the automatic refetch
  return { refetch: false }
}

```

```
onInsert: async ({ transaction }) => {
  await api.createTodos(transaction.mutations.map(m => m.modified))

  // Skip the automatic refetch
  return { refetch: false }
}

```

This is useful when:

- You're confident the server state matches what you sent
- You want to avoid unnecessary network requests
- You're handling state updates through other mechanisms (like WebSockets)

[**Utility Methods**](https://tanstack.com/db/latest/docs/collections/query-collection#utility-methods)

The collection provides these utility methods via collection.utils:

- refetch(): Manually trigger a refetch of the query

[**Direct Writes (Advanced)**](https://tanstack.com/db/latest/docs/collections/query-collection#direct-writes-advanced)

Direct writes are an escape hatch for scenarios where the normal query/mutation flow doesn't fit your needs. They allow you to write directly to the synced data store, bypassing the optimistic update system and query refetch mechanism.

[**Understanding the Data Stores**](https://tanstack.com/db/latest/docs/collections/query-collection#understanding-the-data-stores)

Query Collections maintain two data stores:

1. **Synced Data Store** \- The authoritative state synchronized with the server via queryFn
2. **Optimistic Mutations Store** \- Temporary changes that are applied optimistically before server confirmation

Normal collection operations (insert, update, delete) create optimistic mutations that are:

- Applied immediately to the UI
- Sent to the server via persistence handlers
- Rolled back automatically if the server request fails
- Replaced with server data when the query refetches

Direct writes bypass this system entirely and write directly to the synced data store, making them ideal for handling real-time updates from alternative sources.

[**When to Use Direct Writes**](https://tanstack.com/db/latest/docs/collections/query-collection#when-to-use-direct-writes)

Direct writes should be used when:

- You need to sync real-time updates from WebSockets or server-sent events
- You're dealing with large datasets where refetching everything is too expensive
- You receive incremental updates or server-computed field updates
- You need to implement complex pagination or partial data loading scenarios

[**Individual Write Operations**](https://tanstack.com/db/latest/docs/collections/query-collection#individual-write-operations)

typescript

```
// Insert a new item directly to the synced data store
todosCollection.utils.writeInsert({ id: '1', text: 'Buy milk', completed: false })

// Update an existing item in the synced data store
todosCollection.utils.writeUpdate({ id: '1', completed: true })

// Delete an item from the synced data store
todosCollection.utils.writeDelete('1')

// Upsert (insert or update) in the synced data store
todosCollection.utils.writeUpsert({ id: '1', text: 'Buy milk', completed: false })

```

```
// Insert a new item directly to the synced data store
todosCollection.utils.writeInsert({ id: '1', text: 'Buy milk', completed: false })

// Update an existing item in the synced data store
todosCollection.utils.writeUpdate({ id: '1', completed: true })

// Delete an item from the synced data store
todosCollection.utils.writeDelete('1')

// Upsert (insert or update) in the synced data store
todosCollection.utils.writeUpsert({ id: '1', text: 'Buy milk', completed: false })

```

These operations:

- Write directly to the synced data store
- Do NOT create optimistic mutations
- Do NOT trigger automatic query refetches
- Update the TanStack Query cache immediately
- Are immediately visible in the UI

[**Batch Operations**](https://tanstack.com/db/latest/docs/collections/query-collection#batch-operations)

The writeBatch method allows you to perform multiple operations atomically. Any write operations called within the callback will be collected and executed as a single transaction:

typescript

```
todosCollection.utils.writeBatch(() => {
  todosCollection.utils.writeInsert({ id: '1', text: 'Buy milk' })
  todosCollection.utils.writeInsert({ id: '2', text: 'Walk dog' })
  todosCollection.utils.writeUpdate({ id: '3', completed: true })
  todosCollection.utils.writeDelete('4')
})

```

```
todosCollection.utils.writeBatch(() => {
  todosCollection.utils.writeInsert({ id: '1', text: 'Buy milk' })
  todosCollection.utils.writeInsert({ id: '2', text: 'Walk dog' })
  todosCollection.utils.writeUpdate({ id: '3', completed: true })
  todosCollection.utils.writeDelete('4')
})

```

[**Real-World Example: WebSocket Integration**](https://tanstack.com/db/latest/docs/collections/query-collection#real-world-example-websocket-integration)

typescript

```
// Handle real-time updates from WebSocket without triggering full refetches
ws.on('todos:update', (changes) => {
  todosCollection.utils.writeBatch(() => {
    changes.forEach(change => {
      switch (change.type) {
        case 'insert':
          todosCollection.utils.writeInsert(change.data)
          break
        case 'update':
          todosCollection.utils.writeUpdate(change.data)
          break
        case 'delete':
          todosCollection.utils.writeDelete(change.id)
          break
      }
    })
  })
})

```

```
// Handle real-time updates from WebSocket without triggering full refetches
ws.on('todos:update', (changes) => {
  todosCollection.utils.writeBatch(() => {
    changes.forEach(change => {
      switch (change.type) {
        case 'insert':
          todosCollection.utils.writeInsert(change.data)
          break
        case 'update':
          todosCollection.utils.writeUpdate(change.data)
          break
        case 'delete':
          todosCollection.utils.writeDelete(change.id)
          break
      }
    })
  })
})

```

[**Example: Incremental Updates**](https://tanstack.com/db/latest/docs/collections/query-collection#example-incremental-updates)

typescript

```
// Handle server responses after mutations without full refetch
const createTodo = async (todo) => {
  // Optimistically add the todo
  const tempId = crypto.randomUUID()
  todosCollection.insert({ ...todo, id: tempId })

  try {
    // Send to server
    const serverTodo = await api.createTodo(todo)

    // Sync the server response (with server-generated ID and timestamps)
    // without triggering a full collection refetch
    todosCollection.utils.writeBatch(() => {
      todosCollection.utils.writeDelete(tempId)
      todosCollection.utils.writeInsert(serverTodo)
    })
  } catch (error) {
    // Rollback happens automatically
    throw error
  }
}

```

```
// Handle server responses after mutations without full refetch
const createTodo = async (todo) => {
  // Optimistically add the todo
  const tempId = crypto.randomUUID()
  todosCollection.insert({ ...todo, id: tempId })

  try {
    // Send to server
    const serverTodo = await api.createTodo(todo)

    // Sync the server response (with server-generated ID and timestamps)
    // without triggering a full collection refetch
    todosCollection.utils.writeBatch(() => {
      todosCollection.utils.writeDelete(tempId)
      todosCollection.utils.writeInsert(serverTodo)
    })
  } catch (error) {
    // Rollback happens automatically
    throw error
  }
}

```

[**Example: Large Dataset Pagination**](https://tanstack.com/db/latest/docs/collections/query-collection#example-large-dataset-pagination)

typescript

```
// Load additional pages without refetching existing data
const loadMoreTodos = async (page) => {
  const newTodos = await api.getTodos({ page, limit: 50 })

  // Add new items without affecting existing ones
  todosCollection.utils.writeBatch(() => {
    newTodos.forEach(todo => {
      todosCollection.utils.writeInsert(todo)
    })
  })
}

```

```
// Load additional pages without refetching existing data
const loadMoreTodos = async (page) => {
  const newTodos = await api.getTodos({ page, limit: 50 })

  // Add new items without affecting existing ones
  todosCollection.utils.writeBatch(() => {
    newTodos.forEach(todo => {
      todosCollection.utils.writeInsert(todo)
    })
  })
}

```

[**Important Behaviors**](https://tanstack.com/db/latest/docs/collections/query-collection#important-behaviors) [**Full State Sync**](https://tanstack.com/db/latest/docs/collections/query-collection#full-state-sync)

The query collection treats the queryFn result as the **complete state** of the collection. This means:

- Items present in the collection but not in the query result will be deleted
- Items in the query result but not in the collection will be inserted
- Items present in both will be updated if they differ

[**Empty Array Behavior**](https://tanstack.com/db/latest/docs/collections/query-collection#empty-array-behavior)

When queryFn returns an empty array, **all items in the collection will be deleted**. This is because the collection interprets an empty array as "the server has no items".

typescript

```
// This will delete all items in the collection
queryFn: async () => []

```

```
// This will delete all items in the collection
queryFn: async () => []

```

[**Handling Partial/Incremental Fetches**](https://tanstack.com/db/latest/docs/collections/query-collection#handling-partialincremental-fetches)

Since the query collection expects queryFn to return the complete state, you can handle partial fetches by merging new data with existing data:

typescript

```
const todosCollection = createCollection(
  queryCollectionOptions({
    queryKey: ['todos'],
    queryFn: async ({ queryKey }) => {
      // Get existing data from cache
      const existingData = queryClient.getQueryData(queryKey) || []

      // Fetch only new/updated items (e.g., changes since last sync)
      const lastSyncTime = localStorage.getItem('todos-last-sync')
      const newData = await fetch(`/api/todos?since=${lastSyncTime}`).then(r => r.json())

      // Merge new data with existing data
      const existingMap = new Map(existingData.map(item => [item.id, item]))

      // Apply updates and additions
      newData.forEach(item => {
        existingMap.set(item.id, item)
      })

      // Handle deletions if your API provides them
      if (newData.deletions) {
        newData.deletions.forEach(id => existingMap.delete(id))
      }

      // Update sync time
      localStorage.setItem('todos-last-sync', new Date().toISOString())

      // Return the complete merged state
      return Array.from(existingMap.values())
    },
    queryClient,
    getKey: (item) => item.id,
  })
)

```

```
const todosCollection = createCollection(
  queryCollectionOptions({
    queryKey: ['todos'],
    queryFn: async ({ queryKey }) => {
      // Get existing data from cache
      const existingData = queryClient.getQueryData(queryKey) || []

      // Fetch only new/updated items (e.g., changes since last sync)
      const lastSyncTime = localStorage.getItem('todos-last-sync')
      const newData = await fetch(`/api/todos?since=${lastSyncTime}`).then(r => r.json())

      // Merge new data with existing data
      const existingMap = new Map(existingData.map(item => [item.id, item]))

      // Apply updates and additions
      newData.forEach(item => {
        existingMap.set(item.id, item)
      })

      // Handle deletions if your API provides them
      if (newData.deletions) {
        newData.deletions.forEach(id => existingMap.delete(id))
      }

      // Update sync time
      localStorage.setItem('todos-last-sync', new Date().toISOString())

      // Return the complete merged state
      return Array.from(existingMap.values())
    },
    queryClient,
    getKey: (item) => item.id,
  })
)

```

This pattern allows you to:

- Fetch only incremental changes from your API
- Merge those changes with existing data
- Return the complete state that the collection expects
- Avoid the performance overhead of fetching all data every time

[**Direct Writes and Query Sync**](https://tanstack.com/db/latest/docs/collections/query-collection#direct-writes-and-query-sync)

Direct writes update the collection immediately and also update the TanStack Query cache. However, they do not prevent the normal query sync behavior. If your queryFn returns data that conflicts with your direct writes, the query data will take precedence.

To handle this properly:

1. Use { refetch: false } in your persistence handlers when using direct writes
2. Set appropriate staleTime to prevent unnecessary refetches
3. Design your queryFn to be aware of incremental updates (e.g., only fetch new data)

[**Complete Direct Write API Reference**](https://tanstack.com/db/latest/docs/collections/query-collection#complete-direct-write-api-reference)

All direct write methods are available on collection.utils:

- writeInsert(data): Insert one or more items directly
- writeUpdate(data): Update one or more items directly
- writeDelete(keys): Delete one or more items directly
- writeUpsert(data): Insert or update one or more items directly
- writeBatch(callback): Perform multiple operations atomically
- refetch(): Manually trigger a refetch of the query



# createOptimisticAction

[**Function: createOptimisticAction()**](https://tanstack.com/db/latest/docs/reference/functions/createoptimisticaction#function-createoptimisticaction)

ts

```
function createOptimisticAction<TVariables>(options): (variables) => Transaction

```

```
function createOptimisticAction<TVariables>(options): (variables) => Transaction

```

Defined in: [packages/db/src/optimistic-action.ts:41](https://github.com/TanStack/db/blob/main/packages/db/src/optimistic-action.ts#L41)

Creates an optimistic action function that applies local optimistic updates immediately
before executing the actual mutation on the server.

This pattern allows for responsive UI updates while the actual mutation is in progress.
The optimistic update is applied via the onMutate callback, and the server mutation
is executed via the mutationFn.

[**Type Parameters**](https://tanstack.com/db/latest/docs/reference/functions/createoptimisticaction#type-parameters)

â€¢ **TVariables** = unknown

The type of variables that will be passed to the action function

[**Parameters**](https://tanstack.com/db/latest/docs/reference/functions/createoptimisticaction#parameters) [**options**](https://tanstack.com/db/latest/docs/reference/functions/createoptimisticaction#options)

[CreateOptimisticActionsOptions](https://tanstack.com/db/latest/docs/reference/interfaces/createoptimisticactionsoptions) <TVariables>

Configuration options for the optimistic action

[**Returns**](https://tanstack.com/db/latest/docs/reference/functions/createoptimisticaction#returns)

Function

A function that accepts variables of type TVariables and returns a Transaction

[**Parameters**](https://tanstack.com/db/latest/docs/reference/functions/createoptimisticaction#parameters-1) [**variables**](https://tanstack.com/db/latest/docs/reference/functions/createoptimisticaction#variables)

TVariables

[**Returns**](https://tanstack.com/db/latest/docs/reference/functions/createoptimisticaction#returns-1)

[Transaction](https://tanstack.com/db/latest/docs/reference/classes/transaction)

[**Example**](https://tanstack.com/db/latest/docs/reference/functions/createoptimisticaction#example)

ts

```
const addTodo = createOptimisticAction<string>({
  onMutate: (text) => {
    // Instantly applies local optimistic state
    todoCollection.insert({
      id: uuid(),
      text,
      completed: false
    })
  },
  mutationFn: async (text, params) => {
    // Persist the todo to your backend
    const response = await fetch('/api/todos', {
      method: 'POST',
      body: JSON.stringify({ text, completed: false }),
    })
    return response.json()
  }
})

// Usage
const transaction = addTodo('New Todo Item')

```

```
const addTodo = createOptimisticAction<string>({
  onMutate: (text) => {
    // Instantly applies local optimistic state
    todoCollection.insert({
      id: uuid(),
      text,
      completed: false
    })
  },
  mutationFn: async (text, params) => {
    // Persist the todo to your backend
    const response = await fetch('/api/todos', {
      method: 'POST',
      body: JSON.stringify({ text, completed: false }),
    })
    return response.json()
  }
})

// Usage
const transaction = addTodo('New Todo Item')

```

# Error Handling

[**Error Handling**](https://tanstack.com/db/latest/docs/guides/error-handling#error-handling)

TanStack DB provides comprehensive error handling capabilities to ensure robust data synchronization and state management. This guide covers the built-in error handling mechanisms and how to work with them effectively.

[**Error Types**](https://tanstack.com/db/latest/docs/guides/error-handling#error-types)

TanStack DB provides named error classes for better error handling and type safety. All error classes can be imported from @tanstack/db (or more commonly, the framework-specific package e.g. @tanstack/react-db):

ts

```
import {
  SchemaValidationError,
  CollectionInErrorStateError,
  DuplicateKeyError,
  MissingHandlerError,
  TransactionError,
  // ... and many more
} from "@tanstack/db"

```

```
import {
  SchemaValidationError,
  CollectionInErrorStateError,
  DuplicateKeyError,
  MissingHandlerError,
  TransactionError,
  // ... and many more
} from "@tanstack/db"

```

[**SchemaValidationError**](https://tanstack.com/db/latest/docs/guides/error-handling#schemavalidationerror)

Thrown when data doesn't match the collection's schema during insert or update operations:

ts

```
import { SchemaValidationError } from "@tanstack/db"

try {
  todoCollection.insert({ text: 123 }) // Invalid type
} catch (error) {
  if (error instanceof SchemaValidationError) {
    console.log(error.type) // 'insert' or 'update'
    console.log(error.issues) // Array of validation issues
    // Example issue: { message: "Expected string, received number", path: ["text"] }
  }
}

```

```
import { SchemaValidationError } from "@tanstack/db"

try {
  todoCollection.insert({ text: 123 }) // Invalid type
} catch (error) {
  if (error instanceof SchemaValidationError) {
    console.log(error.type) // 'insert' or 'update'
    console.log(error.issues) // Array of validation issues
    // Example issue: { message: "Expected string, received number", path: ["text"] }
  }
}

```

The error includes:

- type: Whether it was an 'insert' or 'update' operation
- issues: Array of validation issues with messages and paths
- message: A formatted error message listing all issues

[**Collection Status and Error States**](https://tanstack.com/db/latest/docs/guides/error-handling#collection-status-and-error-states)

Collections track their status and transition between states:

tsx

```
import { useLiveQuery } from "@tanstack/react-db"

const TodoList = () => {
  const { data, status, isError, isLoading, isReady } = useLiveQuery(
    (query) => query.from({ todos: todoCollection })
  )

  if (isError) {
    return <div>Collection is in error state</div>
  }

  if (isLoading) {
    return <div>Loading...</div>
  }

  return <div>{data?.map(todo => <div key={todo.id}>{todo.text}</div>)}</div>
}

```

```
import { useLiveQuery } from "@tanstack/react-db"

const TodoList = () => {
  const { data, status, isError, isLoading, isReady } = useLiveQuery(
    (query) => query.from({ todos: todoCollection })
  )

  if (isError) {
    return <div>Collection is in error state</div>
  }

  if (isLoading) {
    return <div>Loading...</div>
  }

  return <div>{data?.map(todo => <div key={todo.id}>{todo.text}</div>)}</div>
}

```

Collection status values:

- idle \- Not yet started
- loading \- Loading initial data
- initialCommit \- Processing initial data
- ready \- Ready for use
- error \- In error state
- cleaned-up \- Cleaned up and no longer usable

[**Transaction Error Handling**](https://tanstack.com/db/latest/docs/guides/error-handling#transaction-error-handling)

When mutations fail, TanStack DB automatically rolls back optimistic updates:

ts

```
const todoCollection = createCollection({
  id: "todos",
  onInsert: async ({ transaction }) => {
    const response = await fetch("/api/todos", {
      method: "POST",
      body: JSON.stringify(transaction.mutations[0].modified),
    })

    if (!response.ok) {
      // Throwing an error will rollback the optimistic state
      throw new Error(`HTTP Error: ${response.status}`)
    }

    return response.json()
  },
})

// Usage - optimistic update will be rolled back if the mutation fails
try {
  const tx = await todoCollection.insert({
    id: "1",
    text: "New todo",
    completed: false,
  })

  await tx.isPersisted.promise
} catch (error) {
  // The optimistic update has been automatically rolled back
  console.error("Failed to create todo:", error)
}

```

```
const todoCollection = createCollection({
  id: "todos",
  onInsert: async ({ transaction }) => {
    const response = await fetch("/api/todos", {
      method: "POST",
      body: JSON.stringify(transaction.mutations[0].modified),
    })

    if (!response.ok) {
      // Throwing an error will rollback the optimistic state
      throw new Error(`HTTP Error: ${response.status}`)
    }

    return response.json()
  },
})

// Usage - optimistic update will be rolled back if the mutation fails
try {
  const tx = await todoCollection.insert({
    id: "1",
    text: "New todo",
    completed: false,
  })

  await tx.isPersisted.promise
} catch (error) {
  // The optimistic update has been automatically rolled back
  console.error("Failed to create todo:", error)
}

```

[**Transaction States and Error Information**](https://tanstack.com/db/latest/docs/guides/error-handling#transaction-states-and-error-information)

Transactions have the following states:

- pending \- Transaction is being processed
- persisting \- Currently executing the mutation function
- completed \- Transaction completed successfully
- failed \- Transaction failed and was rolled back

Access transaction error information from collection operations:

ts

```
const todoCollection = createCollection({
  id: "todos",
  onUpdate: async ({ transaction }) => {
    const response = await fetch(`/api/todos/${transaction.mutations[0].key}`, {
      method: "PUT",
      body: JSON.stringify(transaction.mutations[0].modified),
    })

    if (!response.ok) {
      throw new Error(`Update failed: ${response.status}`)
    }
  },
})

try {
  const tx = await todoCollection.update("todo-1", (draft) => {
    draft.completed = true
  })

  await tx.isPersisted.promise
} catch (error) {
  // Transaction has been rolled back
  console.log(tx.state) // "failed"
  console.log(tx.error) // { message: "Update failed: 500", error: Error }
}

```

```
const todoCollection = createCollection({
  id: "todos",
  onUpdate: async ({ transaction }) => {
    const response = await fetch(`/api/todos/${transaction.mutations[0].key}`, {
      method: "PUT",
      body: JSON.stringify(transaction.mutations[0].modified),
    })

    if (!response.ok) {
      throw new Error(`Update failed: ${response.status}`)
    }
  },
})

try {
  const tx = await todoCollection.update("todo-1", (draft) => {
    draft.completed = true
  })

  await tx.isPersisted.promise
} catch (error) {
  // Transaction has been rolled back
  console.log(tx.state) // "failed"
  console.log(tx.error) // { message: "Update failed: 500", error: Error }
}

```

Or with manual transaction creation:

ts

```
const tx = createTransaction({
  mutationFn: async ({ transaction }) => {
    throw new Error("API failed")
  }
})

tx.mutate(() => {
  collection.insert({ id: "1", text: "Item" })
})

try {
  await tx.commit()
} catch (error) {
  // Transaction has been rolled back
  console.log(tx.state) // "failed"
  console.log(tx.error) // { message: "API failed", error: Error }
}

```

```
const tx = createTransaction({
  mutationFn: async ({ transaction }) => {
    throw new Error("API failed")
  }
})

tx.mutate(() => {
  collection.insert({ id: "1", text: "Item" })
})

try {
  await tx.commit()
} catch (error) {
  // Transaction has been rolled back
  console.log(tx.state) // "failed"
  console.log(tx.error) // { message: "API failed", error: Error }
}

```

[**Collection Operation Errors**](https://tanstack.com/db/latest/docs/guides/error-handling#collection-operation-errors) [**Invalid Collection State**](https://tanstack.com/db/latest/docs/guides/error-handling#invalid-collection-state)

Collections in an error state cannot perform operations and must be manually recovered:

ts

```
import { CollectionInErrorStateError } from "@tanstack/db"

try {
  todoCollection.insert(newTodo)
} catch (error) {
  if (error instanceof CollectionInErrorStateError) {
    // Collection needs to be cleaned up and restarted
    await todoCollection.cleanup()

    // Now retry the operation
    todoCollection.insert(newTodo)
  }
}

```

```
import { CollectionInErrorStateError } from "@tanstack/db"

try {
  todoCollection.insert(newTodo)
} catch (error) {
  if (error instanceof CollectionInErrorStateError) {
    // Collection needs to be cleaned up and restarted
    await todoCollection.cleanup()

    // Now retry the operation
    todoCollection.insert(newTodo)
  }
}

```

[**Missing Mutation Handlers**](https://tanstack.com/db/latest/docs/guides/error-handling#missing-mutation-handlers)

Direct mutations require handlers to be configured:

ts

```
const todoCollection = createCollection({
  id: "todos",
  getKey: (todo) => todo.id,
  // Missing onInsert handler
})

// This will throw an error
todoCollection.insert(newTodo)
// Error: Collection.insert called directly (not within an explicit transaction) but no 'onInsert' handler is configured

```

```
const todoCollection = createCollection({
  id: "todos",
  getKey: (todo) => todo.id,
  // Missing onInsert handler
})

// This will throw an error
todoCollection.insert(newTodo)
// Error: Collection.insert called directly (not within an explicit transaction) but no 'onInsert' handler is configured

```

[**Duplicate Key Errors**](https://tanstack.com/db/latest/docs/guides/error-handling#duplicate-key-errors)

Inserting items with existing keys will throw:

ts

```
import { DuplicateKeyError } from "@tanstack/db"

try {
  todoCollection.insert({ id: "existing-id", text: "Todo" })
} catch (error) {
  if (error instanceof DuplicateKeyError) {
    console.log(`Duplicate key: ${error.message}`)
  }
}

```

```
import { DuplicateKeyError } from "@tanstack/db"

try {
  todoCollection.insert({ id: "existing-id", text: "Todo" })
} catch (error) {
  if (error instanceof DuplicateKeyError) {
    console.log(`Duplicate key: ${error.message}`)
  }
}

```

[**Schema Validation Errors**](https://tanstack.com/db/latest/docs/guides/error-handling#schema-validation-errors)

Schema validation must be synchronous:

ts

```
const todoCollection = createCollection({
  id: "todos",
  getKey: (todo) => todo.id,
  schema: {
    "~standard": {
      validate: async (data) => { // Async validation not allowed
        // ...
      }
    }
  }
})

// Will throw: Schema validation must be synchronous

```

```
const todoCollection = createCollection({
  id: "todos",
  getKey: (todo) => todo.id,
  schema: {
    "~standard": {
      validate: async (data) => { // Async validation not allowed
        // ...
      }
    }
  }
})

// Will throw: Schema validation must be synchronous

```

[**Sync Error Handling**](https://tanstack.com/db/latest/docs/guides/error-handling#sync-error-handling) [**Query Collection Sync Errors**](https://tanstack.com/db/latest/docs/guides/error-handling#query-collection-sync-errors)

Query collections handle sync errors gracefully and mark the collection as ready even on error to avoid blocking applications:

ts

```
import { queryCollectionOptions } from "@tanstack/query-db-collection"

const todoCollection = createCollection(
  queryCollectionOptions({
    queryKey: ["todos"],
    queryFn: async () => {
      const response = await fetch("/api/todos")
      if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.status}`)
      }
      return response.json()
    },
    queryClient,
    getKey: (item) => item.id,
    schema: todoSchema,
    // Standard TanStack Query error handling options
    retry: 3,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  })
)

```

```
import { queryCollectionOptions } from "@tanstack/query-db-collection"

const todoCollection = createCollection(
  queryCollectionOptions({
    queryKey: ["todos"],
    queryFn: async () => {
      const response = await fetch("/api/todos")
      if (!response.ok) {
        throw new Error(`Failed to fetch: ${response.status}`)
      }
      return response.json()
    },
    queryClient,
    getKey: (item) => item.id,
    schema: todoSchema,
    // Standard TanStack Query error handling options
    retry: 3,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  })
)

```

When sync errors occur:

- Error is logged to console: \[QueryCollection\] Error observing query...
- Collection is marked as ready to prevent blocking the application
- Cached data remains available

[**Sync Write Errors**](https://tanstack.com/db/latest/docs/guides/error-handling#sync-write-errors)

Sync functions must handle their own errors during write operations:

ts

```
const collection = createCollection({
  id: "todos",
  sync: {
    sync: ({ begin, write, commit }) => {
      begin()

      try {
        // Will throw if key already exists
        write({ type: "insert", value: { id: "existing-id", text: "Todo" } })
      } catch (error) {
        // Error: Cannot insert document with key "existing-id" from sync because it already exists
      }

      commit()
    }
  }
})

```

```
const collection = createCollection({
  id: "todos",
  sync: {
    sync: ({ begin, write, commit }) => {
      begin()

      try {
        // Will throw if key already exists
        write({ type: "insert", value: { id: "existing-id", text: "Todo" } })
      } catch (error) {
        // Error: Cannot insert document with key "existing-id" from sync because it already exists
      }

      commit()
    }
  }
})

```

[**Cleanup Error Handling**](https://tanstack.com/db/latest/docs/guides/error-handling#cleanup-error-handling)

Cleanup errors are isolated to prevent blocking the cleanup process:

ts

```
const collection = createCollection({
  id: "todos",
  sync: {
    sync: ({ begin, commit }) => {
      begin()
      commit()

      // Return a cleanup function
      return () => {
        // If this throws, the error is re-thrown in a microtask
        // but cleanup continues successfully
        throw new Error("Sync cleanup failed")
      }
    },
  },
})

// Cleanup completes even if the sync cleanup function throws
await collection.cleanup() // Resolves successfully
// Error is re-thrown asynchronously via queueMicrotask

```

```
const collection = createCollection({
  id: "todos",
  sync: {
    sync: ({ begin, commit }) => {
      begin()
      commit()

      // Return a cleanup function
      return () => {
        // If this throws, the error is re-thrown in a microtask
        // but cleanup continues successfully
        throw new Error("Sync cleanup failed")
      }
    },
  },
})

// Cleanup completes even if the sync cleanup function throws
await collection.cleanup() // Resolves successfully
// Error is re-thrown asynchronously via queueMicrotask

```

[**Error Recovery Patterns**](https://tanstack.com/db/latest/docs/guides/error-handling#error-recovery-patterns) [**Collection Cleanup and Restart**](https://tanstack.com/db/latest/docs/guides/error-handling#collection-cleanup-and-restart)

Clean up collections in error states:

ts

```
if (todoCollection.status === "error") {
  // Cleanup will stop sync and reset the collection
  await todoCollection.cleanup()

  // Collection will automatically restart on next access
  todoCollection.preload() // Or any other operation
}

```

```
if (todoCollection.status === "error") {
  // Cleanup will stop sync and reset the collection
  await todoCollection.cleanup()

  // Collection will automatically restart on next access
  todoCollection.preload() // Or any other operation
}

```

[**Graceful Degradation**](https://tanstack.com/db/latest/docs/guides/error-handling#graceful-degradation)

Collections continue to work with cached data even when sync fails:

tsx

```
const TodoApp = () => {
  const { data, isError } = useLiveQuery((query) =>
    query.from({ todos: todoCollection })
  )

  return (
    <div>
      {isError && (
        <div>Sync failed, but you can still view cached data</div>
      )}
      {data?.map(todo => <TodoItem key={todo.id} todo={todo} />)}
    </div>
  )
}

```

```
const TodoApp = () => {
  const { data, isError } = useLiveQuery((query) =>
    query.from({ todos: todoCollection })
  )

  return (
    <div>
      {isError && (
        <div>Sync failed, but you can still view cached data</div>
      )}
      {data?.map(todo => <TodoItem key={todo.id} todo={todo} />)}
    </div>
  )
}

```

[**Transaction Rollback Cascading**](https://tanstack.com/db/latest/docs/guides/error-handling#transaction-rollback-cascading)

When a transaction fails, conflicting transactions are automatically rolled back:

ts

```
const tx1 = createTransaction({ mutationFn: async () => {} })
const tx2 = createTransaction({ mutationFn: async () => {} })

tx1.mutate(() => collection.update("1", draft => { draft.value = "A" }))
tx2.mutate(() => collection.update("1", draft => { draft.value = "B" })) // Same item

// Rolling back tx1 will also rollback tx2 due to conflict
tx1.rollback() // tx2 is automatically rolled back

```

```
const tx1 = createTransaction({ mutationFn: async () => {} })
const tx2 = createTransaction({ mutationFn: async () => {} })

tx1.mutate(() => collection.update("1", draft => { draft.value = "A" }))
tx2.mutate(() => collection.update("1", draft => { draft.value = "B" })) // Same item

// Rolling back tx1 will also rollback tx2 due to conflict
tx1.rollback() // tx2 is automatically rolled back

```

[**Handling Invalid State Errors**](https://tanstack.com/db/latest/docs/guides/error-handling#handling-invalid-state-errors)

Transactions validate their state before operations:

ts

```
const tx = createTransaction({ mutationFn: async () => {} })

// Complete the transaction
await tx.commit()

// These will throw:
tx.mutate(() => {}) // Error: You can no longer call .mutate() as the transaction is no longer pending
tx.commit() // Error: You can no longer call .commit() as the transaction is no longer pending
tx.rollback() // Error: You can no longer call .rollback() as the transaction is already completed

```

```
const tx = createTransaction({ mutationFn: async () => {} })

// Complete the transaction
await tx.commit()

// These will throw:
tx.mutate(() => {}) // Error: You can no longer call .mutate() as the transaction is no longer pending
tx.commit() // Error: You can no longer call .commit() as the transaction is no longer pending
tx.rollback() // Error: You can no longer call .rollback() as the transaction is already completed

```

[**Best Practices**](https://tanstack.com/db/latest/docs/guides/error-handling#best-practices)

1. **Use instanceof checks** \- Use instanceof instead of string matching for error handling:





ts







```
// âœ… Good - type-safe error handling
if (error instanceof SchemaValidationError) {
     // Handle validation error
}

// âŒ Avoid - brittle string matching
if (error.message.includes("validation failed")) {
     // Handle validation error
}

```



```
// âœ… Good - type-safe error handling
if (error instanceof SchemaValidationError) {
     // Handle validation error
}

// âŒ Avoid - brittle string matching
if (error.message.includes("validation failed")) {
     // Handle validation error
}

```

2. **Import specific error types** \- Import only the error classes you need for better tree-shaking

3. **Always handle SchemaValidationError** \- Provide clear feedback for validation failures

4. **Check collection status** \- Use isError, isLoading, isReady flags in React components

5. **Handle transaction promises** \- Always handle isPersisted.promise rejections


[**Example: Complete Error Handling**](https://tanstack.com/db/latest/docs/guides/error-handling#example-complete-error-handling)

tsx

```
import {
  createCollection,
  SchemaValidationError,
  DuplicateKeyError,
  createTransaction
} from "@tanstack/db"
import { useLiveQuery } from "@tanstack/react-db"

const todoCollection = createCollection({
  id: "todos",
  schema: todoSchema,
  getKey: (todo) => todo.id,
  onInsert: async ({ transaction }) => {
    const response = await fetch("/api/todos", {
      method: "POST",
      body: JSON.stringify(transaction.mutations[0].modified),
    })

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }

    return response.json()
  },
  sync: {
    sync: ({ begin, write, commit }) => {
      // Your sync implementation
      begin()
      // ... sync logic
      commit()
    }
  }
})

const TodoApp = () => {
  const { data, status, isError, isLoading } = useLiveQuery(
    (query) => query.from({ todos: todoCollection })
  )

  const handleAddTodo = async (text: string) => {
    try {
      const tx = await todoCollection.insert({
        id: crypto.randomUUID(),
        text,
        completed: false,
      })

      // Wait for persistence
      await tx.isPersisted.promise
    } catch (error) {
      if (error instanceof SchemaValidationError) {
        alert(`Validation error: ${error.issues[0]?.message}`)
      } else if (error instanceof DuplicateKeyError) {
        alert("A todo with this ID already exists")
      } else {
        alert(`Failed to add todo: ${error.message}`)
      }
    }
  }

  const handleCleanup = async () => {
    try {
      await todoCollection.cleanup()
      // Collection will restart on next access
    } catch (error) {
      console.error("Cleanup failed:", error)
    }
  }

  if (isError) {
    return (
      <div>
        <div>Collection error - data may be stale</div>
        <button onClick={handleCleanup}>
          Restart Collection
        </button>
      </div>
    )
  }

  if (isLoading) {
    return <div>Loading todos...</div>
  }

  return (
    <div>
      <button onClick={() => handleAddTodo("New todo")}>
        Add Todo
      </button>
      {data?.map(todo => (
        <div key={todo.id}>{todo.text}</div>
      ))}
    </div>
  )
}

```

```
import {
  createCollection,
  SchemaValidationError,
  DuplicateKeyError,
  createTransaction
} from "@tanstack/db"
import { useLiveQuery } from "@tanstack/react-db"

const todoCollection = createCollection({
  id: "todos",
  schema: todoSchema,
  getKey: (todo) => todo.id,
  onInsert: async ({ transaction }) => {
    const response = await fetch("/api/todos", {
      method: "POST",
      body: JSON.stringify(transaction.mutations[0].modified),
    })

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }

    return response.json()
  },
  sync: {
    sync: ({ begin, write, commit }) => {
      // Your sync implementation
      begin()
      // ... sync logic
      commit()
    }
  }
})

const TodoApp = () => {
  const { data, status, isError, isLoading } = useLiveQuery(
    (query) => query.from({ todos: todoCollection })
  )

  const handleAddTodo = async (text: string) => {
    try {
      const tx = await todoCollection.insert({
        id: crypto.randomUUID(),
        text,
        completed: false,
      })

      // Wait for persistence
      await tx.isPersisted.promise
    } catch (error) {
      if (error instanceof SchemaValidationError) {
        alert(`Validation error: ${error.issues[0]?.message}`)
      } else if (error instanceof DuplicateKeyError) {
        alert("A todo with this ID already exists")
      } else {
        alert(`Failed to add todo: ${error.message}`)
      }
    }
  }

  const handleCleanup = async () => {
    try {
      await todoCollection.cleanup()
      // Collection will restart on next access
    } catch (error) {
      console.error("Cleanup failed:", error)
    }
  }

  if (isError) {
    return (
      <div>
        <div>Collection error - data may be stale</div>
        <button onClick={handleCleanup}>
          Restart Collection
        </button>
      </div>
    )
  }

  if (isLoading) {
    return <div>Loading todos...</div>
  }

  return (
    <div>
      <button onClick={() => handleAddTodo("New todo")}>
        Add Todo
      </button>
      {data?.map(todo => (
        <div key={todo.id}>{todo.text}</div>
      ))}
    </div>
  )
}

```


# liveQueryCollectionOptions

[**Function: liveQueryCollectionOptions()**](https://tanstack.com/db/latest/docs/reference/functions/livequerycollectionoptions#function-livequerycollectionoptions)

ts

```
function liveQueryCollectionOptions<TContext, TResult>(config): CollectionConfig<TResult>

```

```
function liveQueryCollectionOptions<TContext, TResult>(config): CollectionConfig<TResult>

```

Defined in: [packages/db/src/query/live-query-collection.ts:117](https://github.com/TanStack/db/blob/main/packages/db/src/query/live-query-collection.ts#L117)

Creates live query collection options for use with createCollection

[**Type Parameters**](https://tanstack.com/db/latest/docs/reference/functions/livequerycollectionoptions#type-parameters)

â€¢ **TContext** _extends_ [Context](https://tanstack.com/db/latest/docs/reference/interfaces/context)

â€¢ **TResult** _extends_ object = { \[K in string \| number \| symbol\]: (TContext\["result"\] extends object ? any\[any\] : TContext\["hasJoins"\] extends true ? TContext\["schema"\] : TContext\["schema"\]\[TContext\["fromSourceName"\]\])\[K\] }

[**Parameters**](https://tanstack.com/db/latest/docs/reference/functions/livequerycollectionoptions#parameters) [**config**](https://tanstack.com/db/latest/docs/reference/functions/livequerycollectionoptions#config)

[LiveQueryCollectionConfig](https://tanstack.com/db/latest/docs/reference/interfaces/livequerycollectionconfig) <TContext, TResult>

Configuration options for the live query collection

[**Returns**](https://tanstack.com/db/latest/docs/reference/functions/livequerycollectionoptions#returns)

[CollectionConfig](https://tanstack.com/db/latest/docs/reference/interfaces/collectionconfig) <TResult>

Collection options that can be passed to createCollection

[**Example**](https://tanstack.com/db/latest/docs/reference/functions/livequerycollectionoptions#example)

typescript

```
const options = liveQueryCollectionOptions({
  // id is optional - will auto-generate if not provided
  query: (q) => q
    .from({ post: postsCollection })
    .where(({ post }) => eq(post.published, true))
    .select(({ post }) => ({
      id: post.id,
      title: post.title,
      content: post.content,
    })),
  // getKey is optional - will use stream key if not provided
})

const collection = createCollection(options)

```

```
const options = liveQueryCollectionOptions({
  // id is optional - will auto-generate if not provided
  query: (q) => q
    .from({ post: postsCollection })
    .where(({ post }) => eq(post.published, true))
    .select(({ post }) => ({
      id: post.id,
      title: post.title,
      content: post.content,
    })),
  // getKey is optional - will use stream key if not provided
})

const collection = createCollection(options)

```

# Live Queries

[**TanStack DB Live Queries**](https://tanstack.com/db/latest/docs/guides/live-queries#tanstack-db-live-queries)

TanStack DB provides a powerful, type-safe query system that allows you to fetch, filter, transform, and aggregate data from collections using a SQL-like fluent API. All queries are **live** by default, meaning they automatically update when the underlying data changes.

The query system is built around an API similar to SQL query builders like Kysely or Drizzle where you chain methods together to compose your query. The query builder doesn't perform operations in the order of method calls - instead, it composes your query into an optimal incremental pipeline that gets compiled and executed efficiently. Each method returns a new query builder, allowing you to chain operations together.

Live queries resolve to collections that automatically update when their underlying data changes. You can subscribe to changes, iterate over results, and use all the standard collection methods.

ts

```
import { createCollection, liveQueryCollectionOptions, eq } from '@tanstack/db'

const activeUsers = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))
      .select(({ user }) => ({
        id: user.id,
        name: user.name,
        email: user.email,
      }))
}))

```

```
import { createCollection, liveQueryCollectionOptions, eq } from '@tanstack/db'

const activeUsers = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))
      .select(({ user }) => ({
        id: user.id,
        name: user.name,
        email: user.email,
      }))
}))

```

The result types are automatically inferred from your query structure, providing full TypeScript support. When you use a select clause, the result type matches your projection. Without select, you get the full schema with proper join optionality.


[**Creating Live Query Collections**](https://tanstack.com/db/latest/docs/guides/live-queries#creating-live-query-collections)

To create a live query collection, you can use liveQueryCollectionOptions with createCollection, or use the convenience function createLiveQueryCollection.

[**Using liveQueryCollectionOptions**](https://tanstack.com/db/latest/docs/guides/live-queries#using-livequerycollectionoptions)

The fundamental way to create a live query is using liveQueryCollectionOptions with createCollection:

ts

```
import { createCollection, liveQueryCollectionOptions, eq } from '@tanstack/db'

const activeUsers = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))
      .select(({ user }) => ({
        id: user.id,
        name: user.name,
      }))
}))

```

```
import { createCollection, liveQueryCollectionOptions, eq } from '@tanstack/db'

const activeUsers = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))
      .select(({ user }) => ({
        id: user.id,
        name: user.name,
      }))
}))

```

[**Configuration Options**](https://tanstack.com/db/latest/docs/guides/live-queries#configuration-options)

For more control, you can specify additional options:

ts

```
const activeUsers = createCollection(liveQueryCollectionOptions({
  id: 'active-users', // Optional: auto-generated if not provided
  query: (q) =>
    q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))
      .select(({ user }) => ({
        id: user.id,
        name: user.name,
      })),
  getKey: (user) => user.id, // Optional: uses stream key if not provided
  startSync: true, // Optional: starts sync immediately
}))

```

```
const activeUsers = createCollection(liveQueryCollectionOptions({
  id: 'active-users', // Optional: auto-generated if not provided
  query: (q) =>
    q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))
      .select(({ user }) => ({
        id: user.id,
        name: user.name,
      })),
  getKey: (user) => user.id, // Optional: uses stream key if not provided
  startSync: true, // Optional: starts sync immediately
}))

```

| Option | Type | Description |
| --- | --- | --- |
| id | string (optional) | An optional unique identifier for the live query. If not provided, it will be auto-generated. This is useful for debugging and logging. |
| query | QueryBuilder or function | The query definition, this is either a Query instance or a function that returns a Query instance. |
| getKey | (item) => string \| number (optional) | A function that extracts a unique key from each row. If not provided, the stream's internal key will be used. For simple cases this is the key from the parent collection, but in the case of joins, the auto-generated key will be a composite of the parent keys. Using getKey is useful when you want to use a specific key from a parent collection for the resulting collection. |
| schema | Schema (optional) | Optional schema for validation |
| startSync | boolean (optional) | Whether to start syncing immediately. Defaults to true. |
| gcTime | number (optional) | Garbage collection time in milliseconds. Defaults to 5000 (5 seconds). |

[**Convenience Function**](https://tanstack.com/db/latest/docs/guides/live-queries#convenience-function)

For simpler cases, you can use createLiveQueryCollection as a shortcut:

ts

```
import { createLiveQueryCollection, eq } from '@tanstack/db'

const activeUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .where(({ user }) => eq(user.active, true))
    .select(({ user }) => ({
      id: user.id,
      name: user.name,
    }))
)

```

```
import { createLiveQueryCollection, eq } from '@tanstack/db'

const activeUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .where(({ user }) => eq(user.active, true))
    .select(({ user }) => ({
      id: user.id,
      name: user.name,
    }))
)

```

[**Using with Frameworks**](https://tanstack.com/db/latest/docs/guides/live-queries#using-with-frameworks)

In React, you can use the useLiveQuery hook:

tsx

```
import { useLiveQuery } from '@tanstack/react-db'

function UserList() {
  const activeUsers = useLiveQuery((q) =>
    q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))
  )

  return (
    <ul>
      {activeUsers.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  )
}

```

```
import { useLiveQuery } from '@tanstack/react-db'

function UserList() {
  const activeUsers = useLiveQuery((q) =>
    q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))
  )

  return (
    <ul>
      {activeUsers.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  )
}

```

For more details on framework integration, see the [React](https://tanstack.com/docs/framework/react/adapter) and [Vue](https://tanstack.com/docs/framework/vue/adapter) adapter documentation.

[**From Clause**](https://tanstack.com/db/latest/docs/guides/live-queries#from-clause)

The foundation of every query is the from method, which specifies the source collection or subquery. You can alias the source using object syntax.

[**Method Signature**](https://tanstack.com/db/latest/docs/guides/live-queries#method-signature)

ts

```
from({
  [alias]: Collection | Query,
}): Query

```

```
from({
  [alias]: Collection | Query,
}): Query

```

**Parameters:**

- \[alias\] \- A Collection or Query instance. Note that only a single aliased collection or subquery is allowed in the from clause.

[**Basic Usage**](https://tanstack.com/db/latest/docs/guides/live-queries#basic-usage)

Start with a basic query that selects all records from a collection:

ts

```
const allUsers = createCollection(liveQueryCollectionOptions({
  query: (q) => q.from({ user: usersCollection })
}))

```

```
const allUsers = createCollection(liveQueryCollectionOptions({
  query: (q) => q.from({ user: usersCollection })
}))

```

The result contains all users with their full schema. You can iterate over the results or access them by key:

ts

```
// Get all users as an array
const users = allUsers.toArray

// Get a specific user by ID
const user = allUsers.get(1)

// Check if a user exists
const hasUser = allUsers.has(1)

```

```
// Get all users as an array
const users = allUsers.toArray

// Get a specific user by ID
const user = allUsers.get(1)

// Check if a user exists
const hasUser = allUsers.has(1)

```

Use aliases to make your queries more readable, especially when working with multiple collections:

ts

```
const users = createCollection(liveQueryCollectionOptions({
  query: (q) => q.from({ u: usersCollection })
}))

// Access fields using the alias
const userNames = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ u: usersCollection })
      .select(({ u }) => ({
        name: u.name,
        email: u.email,
      }))
}))

```

```
const users = createCollection(liveQueryCollectionOptions({
  query: (q) => q.from({ u: usersCollection })
}))

// Access fields using the alias
const userNames = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ u: usersCollection })
      .select(({ u }) => ({
        name: u.name,
        email: u.email,
      }))
}))

```

[**Where Clauses**](https://tanstack.com/db/latest/docs/guides/live-queries#where-clauses)

Use where clauses to filter your data based on conditions. You can chain multiple where calls - they are combined with and logic.

The where method takes a callback function that receives an object containing your table aliases and returns a boolean expression. You build these expressions using comparison functions like eq(), gt(), and logical operators like and() and or(). This declarative approach allows the query system to optimize your filters efficiently. These are described in more detail in the [Expression Functions Reference](https://tanstack.com/db/latest/docs/guides/live-queries#expression-functions-reference) section. This is very similar to how you construct queries using Kysely or Drizzle.

It's important to note that the where method is not a function that is executed on each row or the results, its a way to describe the query that will be executed. This declarative approach works well for almost all use cases, but if you need to use a more complex condition, there is the functional variant as fn.where which is described in the [Functional Variants](https://tanstack.com/db/latest/docs/guides/live-queries#functional-variants) section.

[**Method Signature**](https://tanstack.com/db/latest/docs/guides/live-queries#method-signature-1)

ts

```
where(
  condition: (row: TRow) => Expression<boolean>
): Query

```

```
where(
  condition: (row: TRow) => Expression<boolean>
): Query

```

**Parameters:**

- condition \- A callback function that receives the row object with table aliases and returns a boolean expression

[**Basic Filtering**](https://tanstack.com/db/latest/docs/guides/live-queries#basic-filtering)

Filter users by a simple condition:

ts

```
import { eq } from '@tanstack/db'

const activeUsers = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))
}))

```

```
import { eq } from '@tanstack/db'

const activeUsers = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))
}))

```

[**Multiple Conditions**](https://tanstack.com/db/latest/docs/guides/live-queries#multiple-conditions)

Chain multiple where calls for AND logic:

ts

```
import { eq, gt } from '@tanstack/db'

const adultActiveUsers = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))
      .where(({ user }) => gt(user.age, 18))
}))

```

```
import { eq, gt } from '@tanstack/db'

const adultActiveUsers = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))
      .where(({ user }) => gt(user.age, 18))
}))

```

[**Complex Conditions**](https://tanstack.com/db/latest/docs/guides/live-queries#complex-conditions)

Use logical operators to build complex conditions:

ts

```
import { eq, gt, or, and } from '@tanstack/db'

const specialUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .where(({ user }) =>
      and(
        eq(user.active, true),
        or(
          gt(user.age, 25),
          eq(user.role, 'admin')
        )
      )
    )
)

```

```
import { eq, gt, or, and } from '@tanstack/db'

const specialUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .where(({ user }) =>
      and(
        eq(user.active, true),
        or(
          gt(user.age, 25),
          eq(user.role, 'admin')
        )
      )
    )
)

```

[**Available Operators**](https://tanstack.com/db/latest/docs/guides/live-queries#available-operators)

The query system provides several comparison operators:

ts

```
import { eq, gt, gte, lt, lte, like, ilike, inArray, and, or, not } from '@tanstack/db'

// Equality
eq(user.id, 1)

// Comparisons
gt(user.age, 18)    // greater than
gte(user.age, 18)   // greater than or equal
lt(user.age, 65)    // less than
lte(user.age, 65)   // less than or equal

// String matching
like(user.name, 'John%')    // case-sensitive pattern matching
ilike(user.name, 'john%')   // case-insensitive pattern matching

// Array membership
inArray(user.id, [1, 2, 3])

// Logical operators
and(condition1, condition2)
or(condition1, condition2)
not(condition)

```

```
import { eq, gt, gte, lt, lte, like, ilike, inArray, and, or, not } from '@tanstack/db'

// Equality
eq(user.id, 1)

// Comparisons
gt(user.age, 18)    // greater than
gte(user.age, 18)   // greater than or equal
lt(user.age, 65)    // less than
lte(user.age, 65)   // less than or equal

// String matching
like(user.name, 'John%')    // case-sensitive pattern matching
ilike(user.name, 'john%')   // case-insensitive pattern matching

// Array membership
inArray(user.id, [1, 2, 3])

// Logical operators
and(condition1, condition2)
or(condition1, condition2)
not(condition)

```

For a complete reference of all available functions, see the [Expression Functions Reference](https://tanstack.com/db/latest/docs/guides/live-queries#expression-functions-reference) section.

[**Select**](https://tanstack.com/db/latest/docs/guides/live-queries#select)

Use select to specify which fields to include in your results and transform your data. Without select, you get the full schema.

Similar to the where clause, the select method takes a callback function that receives an object containing your table aliases and returns an object with the fields you want to include in your results. These can be combined with functions from the [Expression Functions Reference](https://tanstack.com/db/latest/docs/guides/live-queries#expression-functions-reference) section to create computed fields. You can also use the spread operator to include all fields from a table.

[**Method Signature**](https://tanstack.com/db/latest/docs/guides/live-queries#method-signature-2)

ts

```
select(
  projection: (row: TRow) => Record<string, Expression>
): Query

```

```
select(
  projection: (row: TRow) => Record<string, Expression>
): Query

```

**Parameters:**

- projection \- A callback function that receives the row object with table aliases and returns the selected fields object

[**Basic Selects**](https://tanstack.com/db/latest/docs/guides/live-queries#basic-selects)

Select specific fields from your data:

ts

````
const userNames = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .select(({ user }) => ({
      id: user.id,
      name: user.name,
      email: user.email,
    }))
)

/*
Result type: { id: number, name: string, email: string }

```ts
for (const row of userNames) {
console.log(row.name)
}
```
*/

````

````
const userNames = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .select(({ user }) => ({
      id: user.id,
      name: user.name,
      email: user.email,
    }))
)

/*
Result type: { id: number, name: string, email: string }

```ts
for (const row of userNames) {
console.log(row.name)
}
```
*/

````

[**Field Renaming**](https://tanstack.com/db/latest/docs/guides/live-queries#field-renaming)

Rename fields in your results:

ts

```
const userProfiles = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .select(({ user }) => ({
      userId: user.id,
      fullName: user.name,
      contactEmail: user.email,
    }))
)

```

```
const userProfiles = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .select(({ user }) => ({
      userId: user.id,
      fullName: user.name,
      contactEmail: user.email,
    }))
)

```

[**Computed Fields**](https://tanstack.com/db/latest/docs/guides/live-queries#computed-fields)

Create computed fields using expressions:

ts

```
import { gt, length } from '@tanstack/db'

const userStats = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .select(({ user }) => ({
      id: user.id,
      name: user.name,
      isAdult: gt(user.age, 18),
      nameLength: length(user.name),
    }))
)

```

```
import { gt, length } from '@tanstack/db'

const userStats = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .select(({ user }) => ({
      id: user.id,
      name: user.name,
      isAdult: gt(user.age, 18),
      nameLength: length(user.name),
    }))
)

```

[**Using Functions and Including All Fields**](https://tanstack.com/db/latest/docs/guides/live-queries#using-functions-and-including-all-fields)

Transform your data using built-in functions:

ts

```
import { concat, upper, gt } from '@tanstack/db'

const formattedUsers = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .select(({ user }) => ({
        ...user, // Include all user fields
        displayName: upper(concat(user.firstName, ' ', user.lastName)),
        isAdult: gt(user.age, 18),
      }))
}))

/*
Result type:
{
  id: number,
  name: string,
  email: string,
  displayName: string,
  isAdult: boolean,
}
*/

```

```
import { concat, upper, gt } from '@tanstack/db'

const formattedUsers = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .select(({ user }) => ({
        ...user, // Include all user fields
        displayName: upper(concat(user.firstName, ' ', user.lastName)),
        isAdult: gt(user.age, 18),
      }))
}))

/*
Result type:
{
  id: number,
  name: string,
  email: string,
  displayName: string,
  isAdult: boolean,
}
*/

```

For a complete list of available functions, see the [Expression Functions Reference](https://tanstack.com/db/latest/docs/guides/live-queries#expression-functions-reference) section.

[**Joins**](https://tanstack.com/db/latest/docs/guides/live-queries#joins)

Use join to combine data from multiple collections. Joins default to left join type and only support equality conditions.

Joins in TanStack DB are a way to combine data from multiple collections, and are conceptually very similar to SQL joins. When two collections are joined, the result is a new collection that contains the combined data as single rows. The new collection is a live query collection, and will automatically update when the underlying data changes.

A join without a select will return row objects that are namespaced with the aliases of the joined collections.

The result type of a join will take into account the join type, with the optionality of the joined fields being determined by the join type.

Note

We are working on an include system that will enable joins that project to a hierarchical object. For example an issue row could have a comments property that is an array of comment rows.
See [this issue](https://github.com/TanStack/db/issues/288) for more details.

[**Method Signature**](https://tanstack.com/db/latest/docs/guides/live-queries#method-signature-3)

ts

```
join(
  { [alias]: Collection | Query },
  condition: (row: TRow) => Expression<boolean>, // Must be an `eq` condition
  joinType?: 'left' | 'right' | 'inner' | 'full'
): Query

```

```
join(
  { [alias]: Collection | Query },
  condition: (row: TRow) => Expression<boolean>, // Must be an `eq` condition
  joinType?: 'left' | 'right' | 'inner' | 'full'
): Query

```

**Parameters:**

- aliases \- An object where keys are alias names and values are collections or subqueries to join
- condition \- A callback function that receives the combined row object and returns an equality condition
- joinType \- Optional join type: 'left' (default), 'right', 'inner', or 'full'

[**Basic Joins**](https://tanstack.com/db/latest/docs/guides/live-queries#basic-joins)

Join users with their posts:

ts

````
const userPosts = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .join({ post: postsCollection }, ({ user, post }) =>
      eq(user.id, post.userId)
    )
)

/*
Result type:
{
  user: User,
  post?: Post, // post is optional because it is a left join
}

```ts
for (const row of userPosts) {
console.log(row.user.name, row.post?.title)
}
```
*/

````

````
const userPosts = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .join({ post: postsCollection }, ({ user, post }) =>
      eq(user.id, post.userId)
    )
)

/*
Result type:
{
  user: User,
  post?: Post, // post is optional because it is a left join
}

```ts
for (const row of userPosts) {
console.log(row.user.name, row.post?.title)
}
```
*/

````

[**Join Types**](https://tanstack.com/db/latest/docs/guides/live-queries#join-types)

Specify the join type as the third parameter:

ts

```
const activeUserPosts = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .join(
      { post: postsCollection },
      ({ user, post }) => eq(user.id, post.userId),
      'inner', // `inner`, `left`, `right` or `full`
    )
)

```

```
const activeUserPosts = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .join(
      { post: postsCollection },
      ({ user, post }) => eq(user.id, post.userId),
      'inner', // `inner`, `left`, `right` or `full`
    )
)

```

Or using the aliases leftJoin, rightJoin, innerJoin and fullJoin methods:

[**Left Join**](https://tanstack.com/db/latest/docs/guides/live-queries#left-join)

ts

```
// Left join - all users, even without posts
const allUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .leftJoin(
      { post: postsCollection },
      ({ user, post }) => eq(user.id, post.userId),
    )
)

/*
Result type:
{
  user: User,
  post?: Post, // post is optional because it is a left join
}
*/

```

```
// Left join - all users, even without posts
const allUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .leftJoin(
      { post: postsCollection },
      ({ user, post }) => eq(user.id, post.userId),
    )
)

/*
Result type:
{
  user: User,
  post?: Post, // post is optional because it is a left join
}
*/

```

[**Right Join**](https://tanstack.com/db/latest/docs/guides/live-queries#right-join)

ts

```
// Right join - all posts, even without users
const allPosts = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .rightJoin(
      { post: postsCollection },
      ({ user, post }) => eq(user.id, post.userId),
    )
)

/*
Result type:
{
  user?: User, // user is optional because it is a right join
  post: Post,
}
*/

```

```
// Right join - all posts, even without users
const allPosts = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .rightJoin(
      { post: postsCollection },
      ({ user, post }) => eq(user.id, post.userId),
    )
)

/*
Result type:
{
  user?: User, // user is optional because it is a right join
  post: Post,
}
*/

```

[**Inner Join**](https://tanstack.com/db/latest/docs/guides/live-queries#inner-join)

ts

```
// Inner join - only matching records
const activeUserPosts = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .innerJoin(
      { post: postsCollection },
      ({ user, post }) => eq(user.id, post.userId),
    )
)

/*
Result type:
{
  user: User,
  post: Post,
}
*/

```

```
// Inner join - only matching records
const activeUserPosts = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .innerJoin(
      { post: postsCollection },
      ({ user, post }) => eq(user.id, post.userId),
    )
)

/*
Result type:
{
  user: User,
  post: Post,
}
*/

```

[**Full Join**](https://tanstack.com/db/latest/docs/guides/live-queries#full-join)

ts

```
// Full join - all users and all posts
const allUsersAndPosts = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .fullJoin(
      { post: postsCollection },
      ({ user, post }) => eq(user.id, post.userId),
    )
)

/*
Result type:
{
  user?: User, // user is optional because it is a full join
  post?: Post, // post is optional because it is a full join
}
*/

```

```
// Full join - all users and all posts
const allUsersAndPosts = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .fullJoin(
      { post: postsCollection },
      ({ user, post }) => eq(user.id, post.userId),
    )
)

/*
Result type:
{
  user?: User, // user is optional because it is a full join
  post?: Post, // post is optional because it is a full join
}
*/

```

[**Multiple Joins**](https://tanstack.com/db/latest/docs/guides/live-queries#multiple-joins)

Chain multiple joins in a single query:

ts

```
const userPostComments = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .join({ post: postsCollection }, ({ user, post }) =>
      eq(user.id, post.userId)
    )
    .join({ comment: commentsCollection }, ({ post, comment }) =>
      eq(post.id, comment.postId)
    )
    .select(({ user, post, comment }) => ({
      userName: user.name,
      postTitle: post.title,
      commentText: comment.text,
    }))
)

```

```
const userPostComments = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .join({ post: postsCollection }, ({ user, post }) =>
      eq(user.id, post.userId)
    )
    .join({ comment: commentsCollection }, ({ post, comment }) =>
      eq(post.id, comment.postId)
    )
    .select(({ user, post, comment }) => ({
      userName: user.name,
      postTitle: post.title,
      commentText: comment.text,
    }))
)

```

[**Subqueries**](https://tanstack.com/db/latest/docs/guides/live-queries#subqueries)

Subqueries allow you to use the result of one query as input to another, they are embedded within the query itself and are compile to a single query pipeline. They are very similar to SQL subqueries that are executed as part of a single operation.

Note that subqueries are not the same as using a live query result in a from or join clause in a new query. When you do that the intermediate result is fully computed and accessible to you, subqueries are internal to their parent query and not materialised to a collection themselves and so are more efficient.

See the [Caching Intermediate Results](https://tanstack.com/db/latest/docs/guides/live-queries#caching-intermediate-results) section for more details on using live query results in a from or join clause in a new query.

[**Subqueries in from Clauses**](https://tanstack.com/db/latest/docs/guides/live-queries#subqueries-in-from-clauses)

Use a subquery as the main source:

ts

```
const activeUserPosts = createCollection(liveQueryCollectionOptions({
  query: (q) => {
    // Build the subquery first
    const activeUsers = q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))

    // Use the subquery in the main query
    return q
      .from({ activeUser: activeUsers })
      .join({ post: postsCollection }, ({ activeUser, post }) =>
        eq(activeUser.id, post.userId)
      )
  }
}))

```

```
const activeUserPosts = createCollection(liveQueryCollectionOptions({
  query: (q) => {
    // Build the subquery first
    const activeUsers = q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))

    // Use the subquery in the main query
    return q
      .from({ activeUser: activeUsers })
      .join({ post: postsCollection }, ({ activeUser, post }) =>
        eq(activeUser.id, post.userId)
      )
  }
}))

```

[**Subqueries in join Clauses**](https://tanstack.com/db/latest/docs/guides/live-queries#subqueries-in-join-clauses)

Join with a subquery result:

ts

```
const userRecentPosts = createCollection(liveQueryCollectionOptions({
  query: (q) => {
    // Build the subquery first
    const recentPosts = q
      .from({ post: postsCollection })
      .where(({ post }) => gt(post.createdAt, '2024-01-01'))
      .orderBy(({ post }) => post.createdAt, 'desc')
      .limit(1)

    // Use the subquery in the main query
    return q
      .from({ user: usersCollection })
      .join({ recentPost: recentPosts }, ({ user, recentPost }) =>
        eq(user.id, recentPost.userId)
      )
  }
}))

```

```
const userRecentPosts = createCollection(liveQueryCollectionOptions({
  query: (q) => {
    // Build the subquery first
    const recentPosts = q
      .from({ post: postsCollection })
      .where(({ post }) => gt(post.createdAt, '2024-01-01'))
      .orderBy(({ post }) => post.createdAt, 'desc')
      .limit(1)

    // Use the subquery in the main query
    return q
      .from({ user: usersCollection })
      .join({ recentPost: recentPosts }, ({ user, recentPost }) =>
        eq(user.id, recentPost.userId)
      )
  }
}))

```

[**Subquery deduplication**](https://tanstack.com/db/latest/docs/guides/live-queries#subquery-deduplication)

When the same subquery is used multiple times within a query, it's automatically deduplicated and executed only once:

ts

```
const complexQuery = createCollection(liveQueryCollectionOptions({
  query: (q) => {
    // Build the subquery once
    const activeUsers = q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))

    // Use the same subquery multiple times
    return q
      .from({ activeUser: activeUsers })
      .join({ post: postsCollection }, ({ activeUser, post }) =>
        eq(activeUser.id, post.userId)
      )
      .join({ comment: commentsCollection }, ({ activeUser, comment }) =>
        eq(activeUser.id, comment.userId)
      )
  }
}))

```

```
const complexQuery = createCollection(liveQueryCollectionOptions({
  query: (q) => {
    // Build the subquery once
    const activeUsers = q
      .from({ user: usersCollection })
      .where(({ user }) => eq(user.active, true))

    // Use the same subquery multiple times
    return q
      .from({ activeUser: activeUsers })
      .join({ post: postsCollection }, ({ activeUser, post }) =>
        eq(activeUser.id, post.userId)
      )
      .join({ comment: commentsCollection }, ({ activeUser, comment }) =>
        eq(activeUser.id, comment.userId)
      )
  }
}))

```

In this example, the activeUsers subquery is used twice but executed only once, improving performance.

[**Complex Nested Subqueries**](https://tanstack.com/db/latest/docs/guides/live-queries#complex-nested-subqueries)

Build complex queries with multiple levels of nesting:

ts

```
import { count } from '@tanstack/db'

const topUsers = createCollection(liveQueryCollectionOptions({
  query: (q) => {
    // Build the post count subquery
    const postCounts = q
      .from({ post: postsCollection })
      .groupBy(({ post }) => post.userId)
      .select(({ post }) => ({
        userId: post.userId,
        count: count(post.id),
      }))

    // Build the user stats subquery
    const userStats = q
      .from({ user: usersCollection })
      .join({ postCount: postCounts }, ({ user, postCount }) =>
        eq(user.id, postCount.userId)
      )
      .select(({ user, postCount }) => ({
        id: user.id,
        name: user.name,
        postCount: postCount.count,
      }))
      .orderBy(({ userStats }) => userStats.postCount, 'desc')
      .limit(10)

    // Use the user stats subquery in the main query
    return q.from({ userStats })
  }
}))

```

```
import { count } from '@tanstack/db'

const topUsers = createCollection(liveQueryCollectionOptions({
  query: (q) => {
    // Build the post count subquery
    const postCounts = q
      .from({ post: postsCollection })
      .groupBy(({ post }) => post.userId)
      .select(({ post }) => ({
        userId: post.userId,
        count: count(post.id),
      }))

    // Build the user stats subquery
    const userStats = q
      .from({ user: usersCollection })
      .join({ postCount: postCounts }, ({ user, postCount }) =>
        eq(user.id, postCount.userId)
      )
      .select(({ user, postCount }) => ({
        id: user.id,
        name: user.name,
        postCount: postCount.count,
      }))
      .orderBy(({ userStats }) => userStats.postCount, 'desc')
      .limit(10)

    // Use the user stats subquery in the main query
    return q.from({ userStats })
  }
}))

```

[**groupBy and Aggregations**](https://tanstack.com/db/latest/docs/guides/live-queries#groupby-and-aggregations)

Use groupBy to group your data and apply aggregate functions. When you use aggregates in select without groupBy, the entire result set is treated as a single group.

[**Method Signature**](https://tanstack.com/db/latest/docs/guides/live-queries#method-signature-4)

ts

```
groupBy(
  grouper: (row: TRow) => Expression | Expression[]
): Query

```

```
groupBy(
  grouper: (row: TRow) => Expression | Expression[]
): Query

```

**Parameters:**

- grouper \- A callback function that receives the row object and returns the grouping key(s). Can return a single value or an array for multi-column grouping

[**Basic Grouping**](https://tanstack.com/db/latest/docs/guides/live-queries#basic-grouping)

Group users by their department and count them:

ts

```
import { count, avg } from '@tanstack/db'

const departmentStats = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .groupBy(({ user }) => user.departmentId)
      .select(({ user }) => ({
        departmentId: user.departmentId,
        userCount: count(user.id),
        avgAge: avg(user.age),
      }))
}))

```

```
import { count, avg } from '@tanstack/db'

const departmentStats = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .groupBy(({ user }) => user.departmentId)
      .select(({ user }) => ({
        departmentId: user.departmentId,
        userCount: count(user.id),
        avgAge: avg(user.age),
      }))
}))

```

Note

In groupBy queries, the properties in your select clause must either be:

- An aggregate function (like count, sum, avg)
- A property that was used in the groupBy clause

You cannot select properties that are neither aggregated nor grouped.

[**Multiple Column Grouping**](https://tanstack.com/db/latest/docs/guides/live-queries#multiple-column-grouping)

Group by multiple columns by returning an array from the callback:

ts

```
const userStats = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .groupBy(({ user }) => [user.departmentId, user.role])
      .select(({ user }) => ({
        departmentId: user.departmentId,
        role: user.role,
        count: count(user.id),
        avgSalary: avg(user.salary),
      }))
}))

```

```
const userStats = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .groupBy(({ user }) => [user.departmentId, user.role])
      .select(({ user }) => ({
        departmentId: user.departmentId,
        role: user.role,
        count: count(user.id),
        avgSalary: avg(user.salary),
      }))
}))

```

[**Aggregate Functions**](https://tanstack.com/db/latest/docs/guides/live-queries#aggregate-functions)

Use various aggregate functions to summarize your data:

ts

```
import { count, sum, avg, min, max } from '@tanstack/db'

const orderStats = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ order: ordersCollection })
      .groupBy(({ order }) => order.customerId)
      .select(({ order }) => ({
        customerId: order.customerId,
        totalOrders: count(order.id),
        totalAmount: sum(order.amount),
        avgOrderValue: avg(order.amount),
        minOrder: min(order.amount),
        maxOrder: max(order.amount),
      }))
}))

```

```
import { count, sum, avg, min, max } from '@tanstack/db'

const orderStats = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ order: ordersCollection })
      .groupBy(({ order }) => order.customerId)
      .select(({ order }) => ({
        customerId: order.customerId,
        totalOrders: count(order.id),
        totalAmount: sum(order.amount),
        avgOrderValue: avg(order.amount),
        minOrder: min(order.amount),
        maxOrder: max(order.amount),
      }))
}))

```

See the [Aggregate Functions](https://tanstack.com/db/latest/docs/guides/live-queries#aggregate-functions) section for a complete list of available aggregate functions.

[**Having Clauses**](https://tanstack.com/db/latest/docs/guides/live-queries#having-clauses)

Filter aggregated results using having \- this is similar to the where clause, but is applied after the aggregation has been performed.

[**Method Signature**](https://tanstack.com/db/latest/docs/guides/live-queries#method-signature-5)

ts

```
having(
  condition: (row: TRow) => Expression<boolean>
): Query

```

```
having(
  condition: (row: TRow) => Expression<boolean>
): Query

```

**Parameters:**

- condition \- A callback function that receives the aggregated row object and returns a boolean expression

ts

```
const highValueCustomers = createLiveQueryCollection((q) =>
  q
    .from({ order: ordersCollection })
    .groupBy(({ order }) => order.customerId)
    .select(({ order }) => ({
      customerId: order.customerId,
      totalSpent: sum(order.amount),
      orderCount: count(order.id),
    }))
    .having(({ order }) => gt(sum(order.amount), 1000))
)

```

```
const highValueCustomers = createLiveQueryCollection((q) =>
  q
    .from({ order: ordersCollection })
    .groupBy(({ order }) => order.customerId)
    .select(({ order }) => ({
      customerId: order.customerId,
      totalSpent: sum(order.amount),
      orderCount: count(order.id),
    }))
    .having(({ order }) => gt(sum(order.amount), 1000))
)

```

[**Implicit Single-Group Aggregation**](https://tanstack.com/db/latest/docs/guides/live-queries#implicit-single-group-aggregation)

When you use aggregates without groupBy, the entire result set is grouped:

ts

```
const overallStats = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .select(({ user }) => ({
      totalUsers: count(user.id),
      avgAge: avg(user.age),
      maxSalary: max(user.salary),
    }))
)

```

```
const overallStats = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .select(({ user }) => ({
      totalUsers: count(user.id),
      avgAge: avg(user.age),
      maxSalary: max(user.salary),
    }))
)

```

This is equivalent to grouping the entire collection into a single group.

[**Accessing Grouped Data**](https://tanstack.com/db/latest/docs/guides/live-queries#accessing-grouped-data)

Grouped results can be accessed by the group key:

ts

```
const deptStats = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .groupBy(({ user }) => user.departmentId)
      .select(({ user }) => ({
        departmentId: user.departmentId,
        count: count(user.id),
      }))
}))

// Access by department ID
const engineeringStats = deptStats.get(1)

```

```
const deptStats = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .groupBy(({ user }) => user.departmentId)
      .select(({ user }) => ({
        departmentId: user.departmentId,
        count: count(user.id),
      }))
}))

// Access by department ID
const engineeringStats = deptStats.get(1)

```

> **Note**: Grouped results are keyed differently based on the grouping:
>
> - **Single column grouping**: Keyed by the actual value (e.g., deptStats.get(1))
> - **Multiple column grouping**: Keyed by a JSON string of the grouped values (e.g., userStats.get('\[1,"admin"\]'))

[**Order By, Limit, and Offset**](https://tanstack.com/db/latest/docs/guides/live-queries#order-by-limit-and-offset)

Use orderBy, limit, and offset to control the order and pagination of your results. Ordering is performed incrementally for optimal performance.

[**Method Signatures**](https://tanstack.com/db/latest/docs/guides/live-queries#method-signatures)

ts

```
orderBy(
  selector: (row: TRow) => Expression,
  direction?: 'asc' | 'desc'
): Query

limit(count: number): Query

offset(count: number): Query

```

```
orderBy(
  selector: (row: TRow) => Expression,
  direction?: 'asc' | 'desc'
): Query

limit(count: number): Query

offset(count: number): Query

```

**Parameters:**

- selector \- A callback function that receives the row object and returns the value to sort by
- direction \- Sort direction: 'asc' (default) or 'desc'
- count \- Number of rows to limit or skip

[**Basic Ordering**](https://tanstack.com/db/latest/docs/guides/live-queries#basic-ordering)

Sort results by a single column:

ts

```
const sortedUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .orderBy(({ user }) => user.name)
    .select(({ user }) => ({
      id: user.id,
      name: user.name,
    }))
)

```

```
const sortedUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .orderBy(({ user }) => user.name)
    .select(({ user }) => ({
      id: user.id,
      name: user.name,
    }))
)

```

[**Multiple Column Ordering**](https://tanstack.com/db/latest/docs/guides/live-queries#multiple-column-ordering)

Order by multiple columns:

ts

```
const sortedUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .orderBy(({ user }) => user.departmentId, 'asc')
    .orderBy(({ user }) => user.name, 'asc')
    .select(({ user }) => ({
      id: user.id,
      name: user.name,
      departmentId: user.departmentId,
    }))
)

```

```
const sortedUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .orderBy(({ user }) => user.departmentId, 'asc')
    .orderBy(({ user }) => user.name, 'asc')
    .select(({ user }) => ({
      id: user.id,
      name: user.name,
      departmentId: user.departmentId,
    }))
)

```

[**Descending Order**](https://tanstack.com/db/latest/docs/guides/live-queries#descending-order)

Use desc for descending order:

ts

```
const recentPosts = createLiveQueryCollection((q) =>
  q
    .from({ post: postsCollection })
    .orderBy(({ post }) => post.createdAt, 'desc')
    .select(({ post }) => ({
      id: post.id,
      title: post.title,
      createdAt: post.createdAt,
    }))
)

```

```
const recentPosts = createLiveQueryCollection((q) =>
  q
    .from({ post: postsCollection })
    .orderBy(({ post }) => post.createdAt, 'desc')
    .select(({ post }) => ({
      id: post.id,
      title: post.title,
      createdAt: post.createdAt,
    }))
)

```

[**Pagination with limit and offset**](https://tanstack.com/db/latest/docs/guides/live-queries#pagination-with-limit-and-offset)

Skip results using offset:

ts

```
const page2Users = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .orderBy(({ user }) => user.name, 'asc')
    .limit(20)
    .offset(20) // Skip first 20 results
    .select(({ user }) => ({
      id: user.id,
      name: user.name,
    }))
)

```

```
const page2Users = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .orderBy(({ user }) => user.name, 'asc')
    .limit(20)
    .offset(20) // Skip first 20 results
    .select(({ user }) => ({
      id: user.id,
      name: user.name,
    }))
)

```

[**Composable Queries**](https://tanstack.com/db/latest/docs/guides/live-queries#composable-queries)

Build complex queries by composing smaller, reusable parts. This approach makes your queries more maintainable and allows for better performance through caching.

[**Conditional Query Building**](https://tanstack.com/db/latest/docs/guides/live-queries#conditional-query-building)

Build queries based on runtime conditions:

ts

```
import { Query, eq } from '@tanstack/db'

function buildUserQuery(options: { activeOnly?: boolean; limit?: number }) {
  let query = new Query().from({ user: usersCollection })

  if (options.activeOnly) {
    query = query.where(({ user }) => eq(user.active, true))
  }

  if (options.limit) {
    query = query.limit(options.limit)
  }

  return query.select(({ user }) => ({
    id: user.id,
    name: user.name,
  }))
}

const activeUsers = createLiveQueryCollection(buildUserQuery({ activeOnly: true, limit: 10 }))

```

```
import { Query, eq } from '@tanstack/db'

function buildUserQuery(options: { activeOnly?: boolean; limit?: number }) {
  let query = new Query().from({ user: usersCollection })

  if (options.activeOnly) {
    query = query.where(({ user }) => eq(user.active, true))
  }

  if (options.limit) {
    query = query.limit(options.limit)
  }

  return query.select(({ user }) => ({
    id: user.id,
    name: user.name,
  }))
}

const activeUsers = createLiveQueryCollection(buildUserQuery({ activeOnly: true, limit: 10 }))

```

[**Caching Intermediate Results**](https://tanstack.com/db/latest/docs/guides/live-queries#caching-intermediate-results)

The result of a live query collection is a collection itself, and will automatically update when the underlying data changes. This means that you can use the result of a live query collection as a source in another live query collection. This pattern is useful for building complex queries where you want to cache intermediate results to make further queries faster.

ts

```
// Base query for active users
const activeUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .where(({ user }) => eq(user.active, true))
)

// Query that depends on active users
const activeUserPosts = createLiveQueryCollection((q) =>
  q
    .from({ user: activeUsers })
    .join({ post: postsCollection }, ({ user, post }) =>
      eq(user.id, post.userId)
    )
    .select(({ user, post }) => ({
      userName: user.name,
      postTitle: post.title,
    }))
)

```

```
// Base query for active users
const activeUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .where(({ user }) => eq(user.active, true))
)

// Query that depends on active users
const activeUserPosts = createLiveQueryCollection((q) =>
  q
    .from({ user: activeUsers })
    .join({ post: postsCollection }, ({ user, post }) =>
      eq(user.id, post.userId)
    )
    .select(({ user, post }) => ({
      userName: user.name,
      postTitle: post.title,
    }))
)

```

[**Reusable Query Definitions**](https://tanstack.com/db/latest/docs/guides/live-queries#reusable-query-definitions)

You can use the Query class to create reusable query definitions. This is useful for building complex queries where you want to reuse the same query builder instance multiple times throughout your application.

ts

```
import { Query, eq } from '@tanstack/db'

// Create a reusable query builder
const userQuery = new Query()
  .from({ user: usersCollection })
  .where(({ user }) => eq(user.active, true))

// Use it in different contexts
const activeUsers = createLiveQueryCollection({
  query: userQuery.select(({ user }) => ({
    id: user.id,
    name: user.name,
  }))
})

// Or as a subquery
const userPosts = createLiveQueryCollection((q) =>
  q
    .from({ activeUser: userQuery })
    .join({ post: postsCollection }, ({ activeUser, post }) =>
      eq(activeUser.id, post.userId)
    )
)

```

```
import { Query, eq } from '@tanstack/db'

// Create a reusable query builder
const userQuery = new Query()
  .from({ user: usersCollection })
  .where(({ user }) => eq(user.active, true))

// Use it in different contexts
const activeUsers = createLiveQueryCollection({
  query: userQuery.select(({ user }) => ({
    id: user.id,
    name: user.name,
  }))
})

// Or as a subquery
const userPosts = createLiveQueryCollection((q) =>
  q
    .from({ activeUser: userQuery })
    .join({ post: postsCollection }, ({ activeUser, post }) =>
      eq(activeUser.id, post.userId)
    )
)

```

[**Reusable Callback Functions**](https://tanstack.com/db/latest/docs/guides/live-queries#reusable-callback-functions)

Use Ref<MyType> to create reusable callback functions:

ts

```
import { Ref, eq, gt, and } from '@tanstack/db'

// Create reusable callbacks
const isActiveUser = (user: Ref<User>) => eq(user.active, true)
const isAdultUser = (user: Ref<User>) => gt(user.age, 18)

// Use them in queries
const activeAdults = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .where(({ user }) => and(isActiveUser(user), isAdultUser(user)))
      .select(({ user }) => ({
        id: user.id,
        name: user.name,
        age: user.age,
      }))
}))

```

```
import { Ref, eq, gt, and } from '@tanstack/db'

// Create reusable callbacks
const isActiveUser = (user: Ref<User>) => eq(user.active, true)
const isAdultUser = (user: Ref<User>) => gt(user.age, 18)

// Use them in queries
const activeAdults = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .where(({ user }) => and(isActiveUser(user), isAdultUser(user)))
      .select(({ user }) => ({
        id: user.id,
        name: user.name,
        age: user.age,
      }))
}))

```

You can also create callbacks that take the whole row and pass them directly to where:

ts

```
// Callback that takes the whole row
const isHighValueCustomer = (row: { user: User; order: Order }) =>
  row.user.active && row.order.amount > 1000

// Use directly in where clause
const highValueCustomers = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .join({ order: ordersCollection }, ({ user, order }) =>
        eq(user.id, order.userId)
      )
      .where(isHighValueCustomer)
      .select(({ user, order }) => ({
        userName: user.name,
        orderAmount: order.amount,
      }))
}))

```

```
// Callback that takes the whole row
const isHighValueCustomer = (row: { user: User; order: Order }) =>
  row.user.active && row.order.amount > 1000

// Use directly in where clause
const highValueCustomers = createCollection(liveQueryCollectionOptions({
  query: (q) =>
    q
      .from({ user: usersCollection })
      .join({ order: ordersCollection }, ({ user, order }) =>
        eq(user.id, order.userId)
      )
      .where(isHighValueCustomer)
      .select(({ user, order }) => ({
        userName: user.name,
        orderAmount: order.amount,
      }))
}))

```

This approach makes your query logic more modular and testable.

[**Expression Functions Reference**](https://tanstack.com/db/latest/docs/guides/live-queries#expression-functions-reference)

The query system provides a comprehensive set of functions for filtering, transforming, and aggregating data.

[**Comparison Operators**](https://tanstack.com/db/latest/docs/guides/live-queries#comparison-operators) [**eq(left, right)**](https://tanstack.com/db/latest/docs/guides/live-queries#eqleft-right)

Equality comparison:

ts

```
eq(user.id, 1)
eq(user.name, 'John')

```

```
eq(user.id, 1)
eq(user.name, 'John')

```

[**gt(left, right), gte(left, right), lt(left, right), lte(left, right)**](https://tanstack.com/db/latest/docs/guides/live-queries#gtleft-right-gteleft-right-ltleft-right-lteleft-right)

Numeric, string and date comparisons:

ts

```
gt(user.age, 18)
gte(user.salary, 50000)
lt(user.createdAt, new Date('2024-01-01'))
lte(user.rating, 5)

```

```
gt(user.age, 18)
gte(user.salary, 50000)
lt(user.createdAt, new Date('2024-01-01'))
lte(user.rating, 5)

```

[**inArray(value, array)**](https://tanstack.com/db/latest/docs/guides/live-queries#inarrayvalue-array)

Check if a value is in an array:

ts

```
inArray(user.id, [1, 2, 3])
inArray(user.role, ['admin', 'moderator'])

```

```
inArray(user.id, [1, 2, 3])
inArray(user.role, ['admin', 'moderator'])

```

[**like(value, pattern), ilike(value, pattern)**](https://tanstack.com/db/latest/docs/guides/live-queries#likevalue-pattern-ilikevalue-pattern)

String pattern matching:

ts

```
like(user.name, 'John%')    // Case-sensitive
ilike(user.email, '%@gmail.com')  // Case-insensitive

```

```
like(user.name, 'John%')    // Case-sensitive
ilike(user.email, '%@gmail.com')  // Case-insensitive

```

[**Logical Operators**](https://tanstack.com/db/latest/docs/guides/live-queries#logical-operators) [**and(...conditions)**](https://tanstack.com/db/latest/docs/guides/live-queries#andconditions)

Combine conditions with AND logic:

ts

```
and(
  eq(user.active, true),
  gt(user.age, 18),
  eq(user.role, 'user')
)

```

```
and(
  eq(user.active, true),
  gt(user.age, 18),
  eq(user.role, 'user')
)

```

[**or(...conditions)**](https://tanstack.com/db/latest/docs/guides/live-queries#orconditions)

Combine conditions with OR logic:

ts

```
or(
  eq(user.role, 'admin'),
  eq(user.role, 'moderator')
)

```

```
or(
  eq(user.role, 'admin'),
  eq(user.role, 'moderator')
)

```

[**not(condition)**](https://tanstack.com/db/latest/docs/guides/live-queries#notcondition)

Negate a condition:

ts

```
not(eq(user.active, false))

```

```
not(eq(user.active, false))

```

[**String Functions**](https://tanstack.com/db/latest/docs/guides/live-queries#string-functions) [**upper(value), lower(value)**](https://tanstack.com/db/latest/docs/guides/live-queries#uppervalue-lowervalue)

Convert case:

ts

```
upper(user.name)  // 'JOHN'
lower(user.email) // 'john@example.com'

```

```
upper(user.name)  // 'JOHN'
lower(user.email) // 'john@example.com'

```

[**length(value)**](https://tanstack.com/db/latest/docs/guides/live-queries#lengthvalue)

Get string or array length:

ts

```
length(user.name)     // String length
length(user.tags)     // Array length

```

```
length(user.name)     // String length
length(user.tags)     // Array length

```

[**concat(...values)**](https://tanstack.com/db/latest/docs/guides/live-queries#concatvalues)

Concatenate strings:

ts

```
concat(user.firstName, ' ', user.lastName)
concat('User: ', user.name, ' (', user.id, ')')

```

```
concat(user.firstName, ' ', user.lastName)
concat('User: ', user.name, ' (', user.id, ')')

```

[**Mathematical Functions**](https://tanstack.com/db/latest/docs/guides/live-queries#mathematical-functions) [**add(left, right)**](https://tanstack.com/db/latest/docs/guides/live-queries#addleft-right)

Add two numbers:

ts

```
add(user.salary, user.bonus)

```

```
add(user.salary, user.bonus)

```

[**coalesce(...values)**](https://tanstack.com/db/latest/docs/guides/live-queries#coalescevalues)

Return the first non-null value:

ts

```
coalesce(user.displayName, user.name, 'Unknown')

```

```
coalesce(user.displayName, user.name, 'Unknown')

```

[**Aggregate Functions**](https://tanstack.com/db/latest/docs/guides/live-queries#aggregate-functions-1) [**count(value)**](https://tanstack.com/db/latest/docs/guides/live-queries#countvalue)

Count non-null values:

ts

```
count(user.id)        // Count all users
count(user.postId)    // Count users with posts

```

```
count(user.id)        // Count all users
count(user.postId)    // Count users with posts

```

[**sum(value)**](https://tanstack.com/db/latest/docs/guides/live-queries#sumvalue)

Sum numeric values:

ts

```
sum(order.amount)
sum(user.salary)

```

```
sum(order.amount)
sum(user.salary)

```

[**avg(value)**](https://tanstack.com/db/latest/docs/guides/live-queries#avgvalue)

Calculate average:

ts

```
avg(user.salary)
avg(order.amount)

```

```
avg(user.salary)
avg(order.amount)

```

[**min(value), max(value)**](https://tanstack.com/db/latest/docs/guides/live-queries#minvalue-maxvalue)

Find minimum and maximum values:

ts

```
min(user.salary)
max(order.amount)

```

```
min(user.salary)
max(order.amount)

```

[**Function Composition**](https://tanstack.com/db/latest/docs/guides/live-queries#function-composition)

Functions can be composed and chained:

ts

```
// Complex condition
and(
  eq(user.active, true),
  or(
    gt(user.age, 25),
    eq(user.role, 'admin')
  ),
  not(inArray(user.id, bannedUserIds))
)

// Complex transformation
concat(
  upper(user.firstName),
  ' ',
  upper(user.lastName),
  ' (',
  user.id,
  ')'
)

// Complex aggregation
avg(add(user.salary, coalesce(user.bonus, 0)))

```

```
// Complex condition
and(
  eq(user.active, true),
  or(
    gt(user.age, 25),
    eq(user.role, 'admin')
  ),
  not(inArray(user.id, bannedUserIds))
)

// Complex transformation
concat(
  upper(user.firstName),
  ' ',
  upper(user.lastName),
  ' (',
  user.id,
  ')'
)

// Complex aggregation
avg(add(user.salary, coalesce(user.bonus, 0)))

```

[**Functional Variants**](https://tanstack.com/db/latest/docs/guides/live-queries#functional-variants)

The functional variant API provides an alternative to the standard API, offering more flexibility for complex transformations. With functional variants, the callback functions contain actual code that gets executed to perform the operation, giving you the full power of JavaScript at your disposal.

Warning

The functional variant API cannot be optimized by the query optimizer or use collection indexes. It is intended for use in rare cases where the standard API is not sufficient.

[**Functional Select**](https://tanstack.com/db/latest/docs/guides/live-queries#functional-select)

Use fn.select() for complex transformations with JavaScript logic:

ts

```
const userProfiles = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .fn.select((row) => ({
      id: row.user.id,
      displayName: `${row.user.firstName} ${row.user.lastName}`,
      salaryTier: row.user.salary > 100000 ? 'senior' : 'junior',
      emailDomain: row.user.email.split('@')[1],
      isHighEarner: row.user.salary > 75000,
    }))
)

```

```
const userProfiles = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .fn.select((row) => ({
      id: row.user.id,
      displayName: `${row.user.firstName} ${row.user.lastName}`,
      salaryTier: row.user.salary > 100000 ? 'senior' : 'junior',
      emailDomain: row.user.email.split('@')[1],
      isHighEarner: row.user.salary > 75000,
    }))
)

```

[**Functional Where**](https://tanstack.com/db/latest/docs/guides/live-queries#functional-where)

Use fn.where() for complex filtering logic:

ts

```
const specialUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .fn.where((row) => {
      const user = row.user
      return user.active &&
             (user.age > 25 || user.role === 'admin') &&
             user.email.includes('@company.com')
    })
)

```

```
const specialUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .fn.where((row) => {
      const user = row.user
      return user.active &&
             (user.age > 25 || user.role === 'admin') &&
             user.email.includes('@company.com')
    })
)

```

[**Functional Having**](https://tanstack.com/db/latest/docs/guides/live-queries#functional-having)

Use fn.having() for complex aggregation filtering:

ts

```
const highValueCustomers = createLiveQueryCollection((q) =>
  q
    .from({ order: ordersCollection })
    .groupBy(({ order }) => order.customerId)
    .select(({ order }) => ({
      customerId: order.customerId,
      totalSpent: sum(order.amount),
      orderCount: count(order.id),
    }))
    .fn.having((row) => {
      return row.totalSpent > 1000 && row.orderCount >= 3
    })
)

```

```
const highValueCustomers = createLiveQueryCollection((q) =>
  q
    .from({ order: ordersCollection })
    .groupBy(({ order }) => order.customerId)
    .select(({ order }) => ({
      customerId: order.customerId,
      totalSpent: sum(order.amount),
      orderCount: count(order.id),
    }))
    .fn.having((row) => {
      return row.totalSpent > 1000 && row.orderCount >= 3
    })
)

```

[**Complex Transformations**](https://tanstack.com/db/latest/docs/guides/live-queries#complex-transformations)

Functional variants excel at complex data transformations:

ts

```
const userProfiles = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .fn.select((row) => {
      const user = row.user
      const fullName = `${user.firstName} ${user.lastName}`.trim()
      const emailDomain = user.email.split('@')[1]
      const ageGroup = user.age < 25 ? 'young' : user.age < 50 ? 'adult' : 'senior'

      return {
        userId: user.id,
        displayName: fullName || user.name,
        contactInfo: {
          email: user.email,
          domain: emailDomain,
          isCompanyEmail: emailDomain === 'company.com'
        },
        demographics: {
          age: user.age,
          ageGroup: ageGroup,
          isAdult: user.age >= 18
        },
        status: user.active ? 'active' : 'inactive',
        profileStrength: fullName && user.email && user.age ? 'complete' : 'incomplete'
      }
    })
)

```

```
const userProfiles = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .fn.select((row) => {
      const user = row.user
      const fullName = `${user.firstName} ${user.lastName}`.trim()
      const emailDomain = user.email.split('@')[1]
      const ageGroup = user.age < 25 ? 'young' : user.age < 50 ? 'adult' : 'senior'

      return {
        userId: user.id,
        displayName: fullName || user.name,
        contactInfo: {
          email: user.email,
          domain: emailDomain,
          isCompanyEmail: emailDomain === 'company.com'
        },
        demographics: {
          age: user.age,
          ageGroup: ageGroup,
          isAdult: user.age >= 18
        },
        status: user.active ? 'active' : 'inactive',
        profileStrength: fullName && user.email && user.age ? 'complete' : 'incomplete'
      }
    })
)

```

[**Type Inference**](https://tanstack.com/db/latest/docs/guides/live-queries#type-inference)

Functional variants maintain full TypeScript support:

ts

```
const processedUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .fn.select((row): ProcessedUser => ({
      id: row.user.id,
      name: row.user.name.toUpperCase(),
      age: row.user.age,
      ageGroup: row.user.age < 25 ? 'young' : row.user.age < 50 ? 'adult' : 'senior',
    }))
)

```

```
const processedUsers = createLiveQueryCollection((q) =>
  q
    .from({ user: usersCollection })
    .fn.select((row): ProcessedUser => ({
      id: row.user.id,
      name: row.user.name.toUpperCase(),
      age: row.user.age,
      ageGroup: row.user.age < 25 ? 'young' : row.user.age < 50 ? 'adult' : 'senior',
    }))
)

```

[**When to Use Functional Variants**](https://tanstack.com/db/latest/docs/guides/live-queries#when-to-use-functional-variants)

Use functional variants when you need:

- Complex JavaScript logic that can't be expressed with built-in functions
- Integration with external libraries or utilities
- Full JavaScript power for custom operations

The callbacks in functional variants are actual JavaScript functions that get executed, unlike the standard API which uses declarative expressions. This gives you complete control over the logic but comes with the trade-off of reduced optimization opportunities.

However, prefer the standard API when possible, as it provides better performance and optimization opportunities.


# Collection

[**Interface: Collection<T, TKey, TUtils, TSchema, TInsertInput>**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#interface-collectiont-tkey-tutils-tschema-tinsertinput)

Defined in: [packages/db/src/collection.ts:77](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L77)

Enhanced Collection interface that includes both data type T and utilities TUtils

[**Extends**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#extends)

- [CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl) <T, TKey, TUtils, TSchema, TInsertInput>

[**Type Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#type-parameters)

â€¢ **T** _extends_ object = Record<string, unknown>

The type of items in the collection

â€¢ **TKey** _extends_ string \| number = string \| number

The type of the key for the collection

â€¢ **TUtils** _extends_ [UtilsRecord](https://tanstack.com/db/latest/docs/reference/type-aliases/utilsrecord) = {}

The utilities record type

â€¢ **TSchema** _extends_ StandardSchemaV1 = StandardSchemaV1

â€¢ **TInsertInput** _extends_ object = T

The type for insert operations (can be different from T for schemas with defaults)

[**Properties**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#properties) [**config**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#config)

ts

```
config: CollectionConfig<T, TKey, TSchema, TInsertInput>;

```

```
config: CollectionConfig<T, TKey, TSchema, TInsertInput>;

```

Defined in: [packages/db/src/collection.ts:211](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L211)

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [config](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#config-1)

* * *

[**id**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#id)

ts

```
id: string;

```

```
id: string;

```

Defined in: [packages/db/src/collection.ts:331](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L331)

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-1)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [id](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#id)

* * *

[**optimisticDeletes**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#optimisticdeletes)

ts

```
optimisticDeletes: Set<TKey>;

```

```
optimisticDeletes: Set<TKey>;

```

Defined in: [packages/db/src/collection.ts:221](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L221)

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-2)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [optimisticDeletes](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#optimisticdeletes)

* * *

[**optimisticUpserts**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#optimisticupserts)

ts

```
optimisticUpserts: Map<TKey, T>;

```

```
optimisticUpserts: Map<TKey, T>;

```

Defined in: [packages/db/src/collection.ts:220](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L220)

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-3)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [optimisticUpserts](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#optimisticupserts)

* * *

[**pendingSyncedTransactions**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#pendingsyncedtransactions)

ts

```
pendingSyncedTransactions: PendingSyncedTransaction<T>[] = [];

```

```
pendingSyncedTransactions: PendingSyncedTransaction<T>[] = [];

```

Defined in: [packages/db/src/collection.ts:215](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L215)

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-4)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [pendingSyncedTransactions](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#pendingsyncedtransactions)

* * *

[**syncedData**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#synceddata)

ts

```
syncedData:
  | Map<TKey, T>
| SortedMap<TKey, T>;

```

```
syncedData:
  | Map<TKey, T>
| SortedMap<TKey, T>;

```

Defined in: [packages/db/src/collection.ts:216](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L216)

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-5)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [syncedData](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#synceddata)

* * *

[**syncedMetadata**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#syncedmetadata)

ts

```
syncedMetadata: Map<TKey, unknown>;

```

```
syncedMetadata: Map<TKey, unknown>;

```

Defined in: [packages/db/src/collection.ts:217](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L217)

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-6)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [syncedMetadata](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#syncedmetadata)

* * *

[**transactions**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#transactions)

ts

```
transactions: SortedMap<string, Transaction<any>>;

```

```
transactions: SortedMap<string, Transaction<any>>;

```

Defined in: [packages/db/src/collection.ts:214](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L214)

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-7)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [transactions](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#transactions)

* * *

[**utils**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#utils)

ts

```
readonly utils: TUtils;

```

```
readonly utils: TUtils;

```

Defined in: [packages/db/src/collection.ts:84](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L84)

[**Overrides**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#overrides)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [utils](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#utils)

[**Accessors**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#accessors) [**indexes**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#indexes) [**Get Signature**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#get-signature)

ts

```
get indexes(): Map<number, BaseIndex<TKey>>

```

```
get indexes(): Map<number, BaseIndex<TKey>>

```

Defined in: [packages/db/src/collection.ts:1439](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1439)

Get resolved indexes for query optimization

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns)

Map<number, [BaseIndex](https://tanstack.com/db/latest/docs/reference/classes/baseindex) <TKey>>

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-8)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [indexes](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#indexes)

* * *

[**size**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#size) [**Get Signature**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#get-signature-1)

ts

```
get size(): number

```

```
get size(): number

```

Defined in: [packages/db/src/collection.ts:995](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L995)

Get the current size of the collection (cached)

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-1)

number

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-9)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [size](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#size)

* * *

[**state**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#state) [**Get Signature**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#get-signature-2)

ts

```
get state(): Map<TKey, T>

```

```
get state(): Map<TKey, T>

```

Defined in: [packages/db/src/collection.ts:2038](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L2038)

Gets the current state of the collection as a Map

[**Example**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#example)

ts

```
const itemsMap = collection.state
console.log(`Collection has ${itemsMap.size} items`)

for (const [key, item] of itemsMap) {
  console.log(`${key}: ${item.title}`)
}

// Check if specific item exists
if (itemsMap.has("todo-1")) {
  console.log("Todo 1 exists:", itemsMap.get("todo-1"))
}

```

```
const itemsMap = collection.state
console.log(`Collection has ${itemsMap.size} items`)

for (const [key, item] of itemsMap) {
  console.log(`${key}: ${item.title}`)
}

// Check if specific item exists
if (itemsMap.has("todo-1")) {
  console.log("Todo 1 exists:", itemsMap.get("todo-1"))
}

```

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-2)

Map<TKey, T>

Map containing all items in the collection, with keys as identifiers

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-10)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [state](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#state)

* * *

[**status**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#status) [**Get Signature**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#get-signature-3)

ts

```
get status(): CollectionStatus

```

```
get status(): CollectionStatus

```

Defined in: [packages/db/src/collection.ts:336](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L336)

Gets the current status of the collection

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-3)

[CollectionStatus](https://tanstack.com/db/latest/docs/reference/type-aliases/collectionstatus)

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-11)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [status](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#status)

* * *

[**toArray**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#toarray) [**Get Signature**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#get-signature-4)

ts

```
get toArray(): T[]

```

```
get toArray(): T[]

```

Defined in: [packages/db/src/collection.ts:2071](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L2071)

Gets the current state of the collection as an Array

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-4)

T\[\]

An Array containing all items in the collection

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-12)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [toArray](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#toarray)

[**Methods**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#methods) [**\[iterator\]()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#iterator)

ts

```
iterator: IterableIterator<[TKey, T]>

```

```
iterator: IterableIterator<[TKey, T]>

```

Defined in: [packages/db/src/collection.ts:1046](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1046)

Get all entries (virtual derived state)

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-5)

IterableIterator<\[TKey, T\]>

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-13)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [\[iterator\]](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#iterator)

* * *

[**cleanup()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#cleanup)

ts

```
cleanup(): Promise<void>

```

```
cleanup(): Promise<void>

```

Defined in: [packages/db/src/collection.ts:583](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L583)

Clean up the collection by stopping sync and clearing data
This can be called manually or automatically by garbage collection

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-6)

Promise<void>

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-14)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [cleanup](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#cleanup)

* * *

[**commitPendingTransactions()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#commitpendingtransactions)

ts

```
commitPendingTransactions(): void

```

```
commitPendingTransactions(): void

```

Defined in: [packages/db/src/collection.ts:1082](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1082)

Attempts to commit pending synced transactions if there are no active transactions
This method processes operations from pending transactions and applies them to the synced data

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-7)

void

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-15)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [commitPendingTransactions](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#commitpendingtransactions)

* * *

[**createIndex()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#createindex)

ts

```
createIndex<TResolver>(indexCallback, config): IndexProxy<TKey>

```

```
createIndex<TResolver>(indexCallback, config): IndexProxy<TKey>

```

Defined in: [packages/db/src/collection.ts:1344](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1344)

Creates an index on a collection for faster queries.
Indexes significantly improve query performance by allowing binary search
and range queries instead of full scans.

[**Type Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#type-parameters-1)

â€¢ **TResolver** _extends_ [IndexResolver](https://tanstack.com/db/latest/docs/reference/type-aliases/indexresolver) <TKey\> = _typeof_ [BTreeIndex](https://tanstack.com/db/latest/docs/reference/classes/btreeindex)

The type of the index resolver (constructor or async loader)

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters) [**indexCallback**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#indexcallback)

(row) =\> any

Function that extracts the indexed value from each item

[**config**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#config-1)

[IndexOptions](https://tanstack.com/db/latest/docs/reference/interfaces/indexoptions) <TResolver\> = {}

Configuration including index type and type-specific options

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-8)

[IndexProxy](https://tanstack.com/db/latest/docs/reference/classes/indexproxy) <TKey>

An index proxy that provides access to the index when ready

[**Example**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#example-1)

ts

```
// Create a default B+ tree index
const ageIndex = collection.createIndex((row) => row.age)

// Create a ordered index with custom options
const ageIndex = collection.createIndex((row) => row.age, {
  indexType: BTreeIndex,
  options: { compareFn: customComparator },
  name: 'age_btree'
})

// Create an async-loaded index
const textIndex = collection.createIndex((row) => row.content, {
  indexType: async () => {
    const { FullTextIndex } = await import('./indexes/fulltext.js')
    return FullTextIndex
  },
  options: { language: 'en' }
})

```

```
// Create a default B+ tree index
const ageIndex = collection.createIndex((row) => row.age)

// Create a ordered index with custom options
const ageIndex = collection.createIndex((row) => row.age, {
  indexType: BTreeIndex,
  options: { compareFn: customComparator },
  name: 'age_btree'
})

// Create an async-loaded index
const textIndex = collection.createIndex((row) => row.content, {
  indexType: async () => {
    const { FullTextIndex } = await import('./indexes/fulltext.js')
    return FullTextIndex
  },
  options: { language: 'en' }
})

```

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-16)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [createIndex](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#createindex)

* * *

[**currentStateAsChanges()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#currentstateaschanges)

ts

```
currentStateAsChanges(options): ChangeMessage<T, string | number>[]

```

```
currentStateAsChanges(options): ChangeMessage<T, string | number>[]

```

Defined in: [packages/db/src/collection.ts:2113](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L2113)

Returns the current state of the collection as an array of changes

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-1) [**options**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#options)

[CurrentStateAsChangesOptions](https://tanstack.com/db/latest/docs/reference/interfaces/currentstateaschangesoptions) <T\> = {}

Options including optional where filter

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-9)

[ChangeMessage](https://tanstack.com/db/latest/docs/reference/interfaces/changemessage) <T, string \| number>\[\]

An array of changes

[**Example**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#example-2)

ts

```
// Get all items as changes
const allChanges = collection.currentStateAsChanges()

// Get only items matching a condition
const activeChanges = collection.currentStateAsChanges({
  where: (row) => row.status === 'active'
})

// Get only items using a pre-compiled expression
const activeChanges = collection.currentStateAsChanges({
  whereExpression: eq(row.status, 'active')
})

```

```
// Get all items as changes
const allChanges = collection.currentStateAsChanges()

// Get only items matching a condition
const activeChanges = collection.currentStateAsChanges({
  where: (row) => row.status === 'active'
})

// Get only items using a pre-compiled expression
const activeChanges = collection.currentStateAsChanges({
  whereExpression: eq(row.status, 'active')
})

```

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-17)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [currentStateAsChanges](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#currentstateaschanges)

* * *

[**delete()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#delete)

ts

```
delete(keys, config?): Transaction<any>

```

```
delete(keys, config?): Transaction<any>

```

Defined in: [packages/db/src/collection.ts:1939](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1939)

Deletes one or more items from the collection

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-2) [**keys**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#keys)

Single key or array of keys to delete

TKey \| TKey\[\]

[**config?**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#config-2)

[OperationConfig](https://tanstack.com/db/latest/docs/reference/interfaces/operationconfig)

Optional configuration including metadata

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-10)

[Transaction](https://tanstack.com/db/latest/docs/reference/classes/transaction) <any>

A Transaction object representing the delete operation(s)

[**Examples**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#examples)

ts

```
// Delete a single item
const tx = collection.delete("todo-1")
await tx.isPersisted.promise

```

```
// Delete a single item
const tx = collection.delete("todo-1")
await tx.isPersisted.promise

```

ts

```
// Delete multiple items
const tx = collection.delete(["todo-1", "todo-2"])
await tx.isPersisted.promise

```

```
// Delete multiple items
const tx = collection.delete(["todo-1", "todo-2"])
await tx.isPersisted.promise

```

ts

```
// Delete with metadata
const tx = collection.delete("todo-1", { metadata: { reason: "completed" } })
await tx.isPersisted.promise

```

```
// Delete with metadata
const tx = collection.delete("todo-1", { metadata: { reason: "completed" } })
await tx.isPersisted.promise

```

ts

```
// Handle errors
try {
  const tx = collection.delete("item-1")
  await tx.isPersisted.promise
  console.log('Delete successful')
} catch (error) {
  console.log('Delete failed:', error)
}

```

```
// Handle errors
try {
  const tx = collection.delete("item-1")
  await tx.isPersisted.promise
  console.log('Delete successful')
} catch (error) {
  console.log('Delete failed:', error)
}

```

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-18)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [delete](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#delete)

* * *

[**entries()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#entries)

ts

```
entries(): IterableIterator<[TKey, T]>

```

```
entries(): IterableIterator<[TKey, T]>

```

Defined in: [packages/db/src/collection.ts:1034](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1034)

Get all entries (virtual derived state)

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-11)

IterableIterator<\[TKey, T\]>

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-19)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [entries](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#entries)

* * *

[**forEach()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#foreach)

ts

```
forEach(callbackfn): void

```

```
forEach(callbackfn): void

```

Defined in: [packages/db/src/collection.ts:1055](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1055)

Execute a callback for each entry in the collection

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-3) [**callbackfn**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#callbackfn)

(value, key, index) =\> void

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-12)

void

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-20)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [forEach](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#foreach)

* * *

[**generateGlobalKey()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#generateglobalkey)

ts

```
generateGlobalKey(key, item): string

```

```
generateGlobalKey(key, item): string

```

Defined in: [packages/db/src/collection.ts:1306](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1306)

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-4) [**key**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#key)

any

[**item**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#item)

any

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-13)

string

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-21)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [generateGlobalKey](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#generateglobalkey)

* * *

[**get()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#get)

ts

```
get(key): undefined | T

```

```
get(key): undefined | T

```

Defined in: [packages/db/src/collection.ts:959](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L959)

Get the current value for a key (virtual derived state)

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-5) [**key**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#key-1)

TKey

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-14)

undefined \| T

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-22)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [get](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#get)

* * *

[**getKeyFromItem()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#getkeyfromitem)

ts

```
getKeyFromItem(item): TKey

```

```
getKeyFromItem(item): TKey

```

Defined in: [packages/db/src/collection.ts:1302](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1302)

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-6) [**item**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#item-1)

T

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-15)

TKey

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-23)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [getKeyFromItem](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#getkeyfromitem)

* * *

[**has()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#has)

ts

```
has(key): boolean

```

```
has(key): boolean

```

Defined in: [packages/db/src/collection.ts:977](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L977)

Check if a key exists in the collection (virtual derived state)

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-7) [**key**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#key-2)

TKey

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-16)

boolean

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-24)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [has](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#has)

* * *

[**insert()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#insert)

ts

```
insert(data, config?):
  | Transaction<Record<string, unknown>>
| Transaction<T>

```

```
insert(data, config?):
  | Transaction<Record<string, unknown>>
| Transaction<T>

```

Defined in: [packages/db/src/collection.ts:1594](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1594)

Inserts one or more items into the collection

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-8) [**data**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#data)

TInsertInput \| TInsertInput\[\]

[**config?**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#config-3)

[InsertConfig](https://tanstack.com/db/latest/docs/reference/interfaces/insertconfig)

Optional configuration including metadata

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-17)

\| [Transaction](https://tanstack.com/db/latest/docs/reference/classes/transaction) <Record<string, unknown>>
\| [Transaction](https://tanstack.com/db/latest/docs/reference/classes/transaction) <T>

A Transaction object representing the insert operation(s)

[**Throws**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#throws)

If the data fails schema validation

[**Examples**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#examples-1)

ts

```
// Insert a single todo (requires onInsert handler)
const tx = collection.insert({ id: "1", text: "Buy milk", completed: false })
await tx.isPersisted.promise

```

```
// Insert a single todo (requires onInsert handler)
const tx = collection.insert({ id: "1", text: "Buy milk", completed: false })
await tx.isPersisted.promise

```

ts

```
// Insert multiple todos at once
const tx = collection.insert([\
  { id: "1", text: "Buy milk", completed: false },\
  { id: "2", text: "Walk dog", completed: true }\
])
await tx.isPersisted.promise

```

```
// Insert multiple todos at once
const tx = collection.insert([\
  { id: "1", text: "Buy milk", completed: false },\
  { id: "2", text: "Walk dog", completed: true }\
])
await tx.isPersisted.promise

```

ts

```
// Insert with metadata
const tx = collection.insert({ id: "1", text: "Buy groceries" },
  { metadata: { source: "mobile-app" } }
)
await tx.isPersisted.promise

```

```
// Insert with metadata
const tx = collection.insert({ id: "1", text: "Buy groceries" },
  { metadata: { source: "mobile-app" } }
)
await tx.isPersisted.promise

```

ts

```
// Handle errors
try {
  const tx = collection.insert({ id: "1", text: "New item" })
  await tx.isPersisted.promise
  console.log('Insert successful')
} catch (error) {
  console.log('Insert failed:', error)
}

```

```
// Handle errors
try {
  const tx = collection.insert({ id: "1", text: "New item" })
  await tx.isPersisted.promise
  console.log('Insert successful')
} catch (error) {
  console.log('Insert failed:', error)
}

```

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-25)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [insert](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#insert)

* * *

[**isReady()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#isready)

ts

```
isReady(): boolean

```

```
isReady(): boolean

```

Defined in: [packages/db/src/collection.ts:294](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L294)

Check if the collection is ready for use
Returns true if the collection has been marked as ready by its sync implementation

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-18)

boolean

true if the collection is ready, false otherwise

[**Example**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#example-3)

ts

```
if (collection.isReady()) {
  console.log('Collection is ready, data is available')
  // Safe to access collection.state
} else {
  console.log('Collection is still loading')
}

```

```
if (collection.isReady()) {
  console.log('Collection is ready, data is available')
  // Safe to access collection.state
} else {
  console.log('Collection is still loading')
}

```

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-26)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [isReady](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#isready)

* * *

[**keys()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#keys-1)

ts

```
keys(): IterableIterator<TKey>

```

```
keys(): IterableIterator<TKey>

```

Defined in: [packages/db/src/collection.ts:1002](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1002)

Get all keys (virtual derived state)

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-19)

IterableIterator<TKey>

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-27)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [keys](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#keys-1)

* * *

[**map()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#map)

ts

```
map<U>(callbackfn): U[]

```

```
map<U>(callbackfn): U[]

```

Defined in: [packages/db/src/collection.ts:1067](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1067)

Create a new array with the results of calling a function for each entry in the collection

[**Type Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#type-parameters-2)

â€¢ **U**

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-9) [**callbackfn**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#callbackfn-1)

(value, key, index) =\> U

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-20)

U\[\]

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-28)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [map](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#map)

* * *

[**onFirstReady()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#onfirstready)

ts

```
onFirstReady(callback): void

```

```
onFirstReady(callback): void

```

Defined in: [packages/db/src/collection.ts:272](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L272)

Register a callback to be executed when the collection first becomes ready
Useful for preloading collections

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-10) [**callback**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#callback)

() =\> void

Function to call when the collection first becomes ready

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-21)

void

[**Example**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#example-4)

ts

```
collection.onFirstReady(() => {
  console.log('Collection is ready for the first time')
  // Safe to access collection.state now
})

```

```
collection.onFirstReady(() => {
  console.log('Collection is ready for the first time')
  // Safe to access collection.state now
})

```

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-29)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [onFirstReady](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#onfirstready)

* * *

[**onTransactionStateChange()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#ontransactionstatechange)

ts

```
onTransactionStateChange(): void

```

```
onTransactionStateChange(): void

```

Defined in: [packages/db/src/collection.ts:2271](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L2271)

Trigger a recomputation when transactions change
This method should be called by the Transaction class when state changes

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-22)

void

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-30)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [onTransactionStateChange](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#ontransactionstatechange)

* * *

[**preload()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#preload)

ts

```
preload(): Promise<void>

```

```
preload(): Promise<void>

```

Defined in: [packages/db/src/collection.ts:544](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L544)

Preload the collection data by starting sync if not already started
Multiple concurrent calls will share the same promise

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-23)

Promise<void>

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-31)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [preload](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#preload)

* * *

[**startSyncImmediate()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#startsyncimmediate)

ts

```
startSyncImmediate(): void

```

```
startSyncImmediate(): void

```

Defined in: [packages/db/src/collection.ts:450](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L450)

Start sync immediately - internal method for compiled queries
This bypasses lazy loading for special cases like live query results

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-24)

void

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-32)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [startSyncImmediate](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#startsyncimmediate)

* * *

[**stateWhenReady()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#statewhenready)

ts

```
stateWhenReady(): Promise<Map<TKey, T>>

```

```
stateWhenReady(): Promise<Map<TKey, T>>

```

Defined in: [packages/db/src/collection.ts:2052](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L2052)

Gets the current state of the collection as a Map, but only resolves when data is available
Waits for the first sync commit to complete before resolving

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-25)

Promise<Map<TKey, T>>

Promise that resolves to a Map containing all items in the collection

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-33)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [stateWhenReady](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#statewhenready)

* * *

[**subscribeChanges()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#subscribechanges)

ts

```
subscribeChanges(callback, options): () => void

```

```
subscribeChanges(callback, options): () => void

```

Defined in: [packages/db/src/collection.ts:2158](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L2158)

Subscribe to changes in the collection

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-11) [**callback**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#callback-1)

(changes) =\> void

Function called when items change

[**options**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#options-1)

[SubscribeChangesOptions](https://tanstack.com/db/latest/docs/reference/interfaces/subscribechangesoptions) <T\> = {}

Subscription options including includeInitialState and where filter

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-26)

Function

Unsubscribe function - Call this to stop listening for changes

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-27)

void

[**Examples**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#examples-2)

ts

```
// Basic subscription
const unsubscribe = collection.subscribeChanges((changes) => {
  changes.forEach(change => {
    console.log(`${change.type}: ${change.key}`, change.value)
  })
})

// Later: unsubscribe()

```

```
// Basic subscription
const unsubscribe = collection.subscribeChanges((changes) => {
  changes.forEach(change => {
    console.log(`${change.type}: ${change.key}`, change.value)
  })
})

// Later: unsubscribe()

```

ts

```
// Include current state immediately
const unsubscribe = collection.subscribeChanges((changes) => {
  updateUI(changes)
}, { includeInitialState: true })

```

```
// Include current state immediately
const unsubscribe = collection.subscribeChanges((changes) => {
  updateUI(changes)
}, { includeInitialState: true })

```

ts

```
// Subscribe only to changes matching a condition
const unsubscribe = collection.subscribeChanges((changes) => {
  updateUI(changes)
}, {
  includeInitialState: true,
  where: (row) => row.status === 'active'
})

```

```
// Subscribe only to changes matching a condition
const unsubscribe = collection.subscribeChanges((changes) => {
  updateUI(changes)
}, {
  includeInitialState: true,
  where: (row) => row.status === 'active'
})

```

ts

```
// Subscribe using a pre-compiled expression
const unsubscribe = collection.subscribeChanges((changes) => {
  updateUI(changes)
}, {
  includeInitialState: true,
  whereExpression: eq(row.status, 'active')
})

```

```
// Subscribe using a pre-compiled expression
const unsubscribe = collection.subscribeChanges((changes) => {
  updateUI(changes)
}, {
  includeInitialState: true,
  whereExpression: eq(row.status, 'active')
})

```

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-34)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [subscribeChanges](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#subscribechanges)

* * *

[**subscribeChangesKey()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#subscribechangeskey)

ts

```
subscribeChangesKey(
   key,
   listener,
   __namedParameters): () => void

```

```
subscribeChangesKey(
   key,
   listener,
   __namedParameters): () => void

```

Defined in: [packages/db/src/collection.ts:2197](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L2197)

Subscribe to changes for a specific key

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-12) [**key**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#key-3)

TKey

[**listener**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#listener)

[ChangeListener](https://tanstack.com/db/latest/docs/reference/type-aliases/changelistener) <T, TKey>

[**\_\_namedParameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#__namedparameters) [**includeInitialState?**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#includeinitialstate)

boolean = false

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-28)

Function

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-29)

void

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-35)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [subscribeChangesKey](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#subscribechangeskey)

* * *

[**toArrayWhenReady()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#toarraywhenready)

ts

```
toArrayWhenReady(): Promise<T[]>

```

```
toArrayWhenReady(): Promise<T[]>

```

Defined in: [packages/db/src/collection.ts:2081](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L2081)

Gets the current state of the collection as an Array, but only resolves when data is available
Waits for the first sync commit to complete before resolving

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-30)

Promise<T\[\]>

Promise that resolves to an Array containing all items in the collection

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-36)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [toArrayWhenReady](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#toarraywhenready)

* * *

[**update()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#update) [**Call Signature**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#call-signature)

ts

```
update<TItem>(key, callback): Transaction

```

```
update<TItem>(key, callback): Transaction

```

Defined in: [packages/db/src/collection.ts:1725](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1725)

Updates one or more items in the collection using a callback function

[**Type Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#type-parameters-3)

â€¢ **TItem** _extends_ object = T

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-13) [**key**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#key-4)

unknown\[\]

[**callback**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#callback-2)

(drafts) =\> void

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-31)

[Transaction](https://tanstack.com/db/latest/docs/reference/classes/transaction)

A Transaction object representing the update operation(s)

[**Throws**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#throws-1)

If the updated data fails schema validation

[**Examples**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#examples-3)

ts

```
// Update single item by key
const tx = collection.update("todo-1", (draft) => {
  draft.completed = true
})
await tx.isPersisted.promise

```

```
// Update single item by key
const tx = collection.update("todo-1", (draft) => {
  draft.completed = true
})
await tx.isPersisted.promise

```

ts

```
// Update multiple items
const tx = collection.update(["todo-1", "todo-2"], (drafts) => {
  drafts.forEach(draft => { draft.completed = true })
})
await tx.isPersisted.promise

```

```
// Update multiple items
const tx = collection.update(["todo-1", "todo-2"], (drafts) => {
  drafts.forEach(draft => { draft.completed = true })
})
await tx.isPersisted.promise

```

ts

```
// Update with metadata
const tx = collection.update("todo-1",
  { metadata: { reason: "user update" } },
  (draft) => { draft.text = "Updated text" }
)
await tx.isPersisted.promise

```

```
// Update with metadata
const tx = collection.update("todo-1",
  { metadata: { reason: "user update" } },
  (draft) => { draft.text = "Updated text" }
)
await tx.isPersisted.promise

```

ts

```
// Handle errors
try {
  const tx = collection.update("item-1", draft => { draft.value = "new" })
  await tx.isPersisted.promise
  console.log('Update successful')
} catch (error) {
  console.log('Update failed:', error)
}

```

```
// Handle errors
try {
  const tx = collection.update("item-1", draft => { draft.value = "new" })
  await tx.isPersisted.promise
  console.log('Update successful')
} catch (error) {
  console.log('Update failed:', error)
}

```

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-37)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [update](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#update)

[**Call Signature**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#call-signature-1)

ts

```
update<TItem>(
   keys,
   config,
   callback): Transaction

```

```
update<TItem>(
   keys,
   config,
   callback): Transaction

```

Defined in: [packages/db/src/collection.ts:1731](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1731)

Updates one or more items in the collection using a callback function

[**Type Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#type-parameters-4)

â€¢ **TItem** _extends_ object = T

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-14) [**keys**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#keys-2)

unknown\[\]

Single key or array of keys to update

[**config**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#config-4)

[OperationConfig](https://tanstack.com/db/latest/docs/reference/interfaces/operationconfig)

[**callback**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#callback-3)

(drafts) =\> void

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-32)

[Transaction](https://tanstack.com/db/latest/docs/reference/classes/transaction)

A Transaction object representing the update operation(s)

[**Throws**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#throws-2)

If the updated data fails schema validation

[**Examples**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#examples-4)

ts

```
// Update single item by key
const tx = collection.update("todo-1", (draft) => {
  draft.completed = true
})
await tx.isPersisted.promise

```

```
// Update single item by key
const tx = collection.update("todo-1", (draft) => {
  draft.completed = true
})
await tx.isPersisted.promise

```

ts

```
// Update multiple items
const tx = collection.update(["todo-1", "todo-2"], (drafts) => {
  drafts.forEach(draft => { draft.completed = true })
})
await tx.isPersisted.promise

```

```
// Update multiple items
const tx = collection.update(["todo-1", "todo-2"], (drafts) => {
  drafts.forEach(draft => { draft.completed = true })
})
await tx.isPersisted.promise

```

ts

```
// Update with metadata
const tx = collection.update("todo-1",
  { metadata: { reason: "user update" } },
  (draft) => { draft.text = "Updated text" }
)
await tx.isPersisted.promise

```

```
// Update with metadata
const tx = collection.update("todo-1",
  { metadata: { reason: "user update" } },
  (draft) => { draft.text = "Updated text" }
)
await tx.isPersisted.promise

```

ts

```
// Handle errors
try {
  const tx = collection.update("item-1", draft => { draft.value = "new" })
  await tx.isPersisted.promise
  console.log('Update successful')
} catch (error) {
  console.log('Update failed:', error)
}

```

```
// Handle errors
try {
  const tx = collection.update("item-1", draft => { draft.value = "new" })
  await tx.isPersisted.promise
  console.log('Update successful')
} catch (error) {
  console.log('Update failed:', error)
}

```

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-38)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [update](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#update)

[**Call Signature**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#call-signature-2)

ts

```
update<TItem>(id, callback): Transaction

```

```
update<TItem>(id, callback): Transaction

```

Defined in: [packages/db/src/collection.ts:1738](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1738)

Updates one or more items in the collection using a callback function

[**Type Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#type-parameters-5)

â€¢ **TItem** _extends_ object = T

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-15) [**id**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#id-1)

unknown

[**callback**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#callback-4)

(draft) =\> void

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-33)

[Transaction](https://tanstack.com/db/latest/docs/reference/classes/transaction)

A Transaction object representing the update operation(s)

[**Throws**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#throws-3)

If the updated data fails schema validation

[**Examples**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#examples-5)

ts

```
// Update single item by key
const tx = collection.update("todo-1", (draft) => {
  draft.completed = true
})
await tx.isPersisted.promise

```

```
// Update single item by key
const tx = collection.update("todo-1", (draft) => {
  draft.completed = true
})
await tx.isPersisted.promise

```

ts

```
// Update multiple items
const tx = collection.update(["todo-1", "todo-2"], (drafts) => {
  drafts.forEach(draft => { draft.completed = true })
})
await tx.isPersisted.promise

```

```
// Update multiple items
const tx = collection.update(["todo-1", "todo-2"], (drafts) => {
  drafts.forEach(draft => { draft.completed = true })
})
await tx.isPersisted.promise

```

ts

```
// Update with metadata
const tx = collection.update("todo-1",
  { metadata: { reason: "user update" } },
  (draft) => { draft.text = "Updated text" }
)
await tx.isPersisted.promise

```

```
// Update with metadata
const tx = collection.update("todo-1",
  { metadata: { reason: "user update" } },
  (draft) => { draft.text = "Updated text" }
)
await tx.isPersisted.promise

```

ts

```
// Handle errors
try {
  const tx = collection.update("item-1", draft => { draft.value = "new" })
  await tx.isPersisted.promise
  console.log('Update successful')
} catch (error) {
  console.log('Update failed:', error)
}

```

```
// Handle errors
try {
  const tx = collection.update("item-1", draft => { draft.value = "new" })
  await tx.isPersisted.promise
  console.log('Update successful')
} catch (error) {
  console.log('Update failed:', error)
}

```

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-39)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [update](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#update)

[**Call Signature**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#call-signature-3)

ts

```
update<TItem>(
   id,
   config,
   callback): Transaction

```

```
update<TItem>(
   id,
   config,
   callback): Transaction

```

Defined in: [packages/db/src/collection.ts:1744](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1744)

Updates one or more items in the collection using a callback function

[**Type Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#type-parameters-6)

â€¢ **TItem** _extends_ object = T

[**Parameters**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#parameters-16) [**id**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#id-2)

unknown

[**config**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#config-5)

[OperationConfig](https://tanstack.com/db/latest/docs/reference/interfaces/operationconfig)

[**callback**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#callback-5)

(draft) =\> void

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-34)

[Transaction](https://tanstack.com/db/latest/docs/reference/classes/transaction)

A Transaction object representing the update operation(s)

[**Throws**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#throws-4)

If the updated data fails schema validation

[**Examples**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#examples-6)

ts

```
// Update single item by key
const tx = collection.update("todo-1", (draft) => {
  draft.completed = true
})
await tx.isPersisted.promise

```

```
// Update single item by key
const tx = collection.update("todo-1", (draft) => {
  draft.completed = true
})
await tx.isPersisted.promise

```

ts

```
// Update multiple items
const tx = collection.update(["todo-1", "todo-2"], (drafts) => {
  drafts.forEach(draft => { draft.completed = true })
})
await tx.isPersisted.promise

```

```
// Update multiple items
const tx = collection.update(["todo-1", "todo-2"], (drafts) => {
  drafts.forEach(draft => { draft.completed = true })
})
await tx.isPersisted.promise

```

ts

```
// Update with metadata
const tx = collection.update("todo-1",
  { metadata: { reason: "user update" } },
  (draft) => { draft.text = "Updated text" }
)
await tx.isPersisted.promise

```

```
// Update with metadata
const tx = collection.update("todo-1",
  { metadata: { reason: "user update" } },
  (draft) => { draft.text = "Updated text" }
)
await tx.isPersisted.promise

```

ts

```
// Handle errors
try {
  const tx = collection.update("item-1", draft => { draft.value = "new" })
  await tx.isPersisted.promise
  console.log('Update successful')
} catch (error) {
  console.log('Update failed:', error)
}

```

```
// Handle errors
try {
  const tx = collection.update("item-1", draft => { draft.value = "new" })
  await tx.isPersisted.promise
  console.log('Update successful')
} catch (error) {
  console.log('Update failed:', error)
}

```

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-40)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [update](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#update)

* * *

[**values()**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#values)

ts

```
values(): IterableIterator<T>

```

```
values(): IterableIterator<T>

```

Defined in: [packages/db/src/collection.ts:1022](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L1022)

Get all values (virtual derived state)

[**Returns**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#returns-35)

IterableIterator<T>

[**Inherited from**](https://tanstack.com/db/latest/docs/reference/interfaces/collection#inherited-from-41)

[CollectionImpl](https://tanstack.com/db/latest/docs/reference/classes/collectionimpl). [values](https://tanstack.com/db/latest/docs/reference/classes/CollectionImpl#values)

# Creating a Collection Options Creator

[**Creating a Collection Options Creator**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#creating-a-collection-options-creator)

A collection options creator is a factory function that generates configuration options for TanStack DB collections. It provides a standardized way to integrate different sync engines and data sources with TanStack DB's reactive sync-first architecture.

[**Overview**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#overview)

Collection options creators follow a consistent pattern:

1. Accept configuration specific to the sync engine
2. Return an object that satisfies the CollectionConfig interface
3. Handle sync initialization, data parsing, and transaction management
4. Optionally provide utility functions specific to the sync engine

[**When to Create a Custom Collection**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#when-to-create-a-custom-collection)

You should create a custom collection when:

- You have a dedicated sync engine (like ElectricSQL, Trailbase, Firebase, or a custom WebSocket solution)
- You need specific sync behaviors that aren't covered by the query collection
- You want to integrate with a backend that has its own sync protocol

**Note**: If you're just hitting an API and returning data, use the query collection instead.

[**Core Requirements**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#core-requirements)

Every collection options creator must implement these key responsibilities:

[**1\. Configuration Interface**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#1-configuration-interface)

Define a configuration interface that extends or includes standard collection properties:

typescript

```
// Pattern A: User provides handlers (Query / ElectricSQL style)
interface MyCollectionConfig<TItem extends object> {
  // Your sync engine specific options
  connectionUrl: string
  apiKey?: string

  // Standard collection properties
  id?: string
  schema?: StandardSchemaV1
  getKey: (item: TItem) => string | number
  sync?: SyncConfig<TItem>

  rowUpdateMode?: 'partial' | 'full'

  // User provides mutation handlers
  onInsert?: InsertMutationFn<TItem>
  onUpdate?: UpdateMutationFn<TItem>
  onDelete?: DeleteMutationFn<TItem>
}

// Pattern B: Built-in handlers (Trailbase style)
interface MyCollectionConfig<TItem extends object>
  extends Omit<CollectionConfig<TItem>, 'onInsert' | 'onUpdate' | 'onDelete'> {
  // Your sync engine specific options
  recordApi: MyRecordApi<TItem>
  connectionUrl: string

  rowUpdateMode?: 'partial' | 'full'

  // Note: onInsert/onUpdate/onDelete are implemented by your collection creator
}

```

```
// Pattern A: User provides handlers (Query / ElectricSQL style)
interface MyCollectionConfig<TItem extends object> {
  // Your sync engine specific options
  connectionUrl: string
  apiKey?: string

  // Standard collection properties
  id?: string
  schema?: StandardSchemaV1
  getKey: (item: TItem) => string | number
  sync?: SyncConfig<TItem>

  rowUpdateMode?: 'partial' | 'full'

  // User provides mutation handlers
  onInsert?: InsertMutationFn<TItem>
  onUpdate?: UpdateMutationFn<TItem>
  onDelete?: DeleteMutationFn<TItem>
}

// Pattern B: Built-in handlers (Trailbase style)
interface MyCollectionConfig<TItem extends object>
  extends Omit<CollectionConfig<TItem>, 'onInsert' | 'onUpdate' | 'onDelete'> {
  // Your sync engine specific options
  recordApi: MyRecordApi<TItem>
  connectionUrl: string

  rowUpdateMode?: 'partial' | 'full'

  // Note: onInsert/onUpdate/onDelete are implemented by your collection creator
}

```

[**2\. Sync Implementation**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#2-sync-implementation)

The sync function is the heart of your collection. It must:

The sync function must return a cleanup function for proper garbage collection:

typescript

```
const sync: SyncConfig<T>['sync'] = (params) => {
  const { begin, write, commit, markReady, collection } = params

  // 1. Initialize connection to your sync engine
  const connection = initializeConnection(config)

  // 2. Set up real-time subscription FIRST (prevents race conditions)
  const eventBuffer: Array<any> = []
  let isInitialSyncComplete = false

  connection.subscribe((event) => {
    if (!isInitialSyncComplete) {
      // Buffer events during initial sync to prevent race conditions
      eventBuffer.push(event)
      return
    }

    // Process real-time events
    begin()

    switch (event.type) {
      case 'insert':
        write({ type: 'insert', value: event.data })
        break
      case 'update':
        write({ type: 'update', value: event.data })
        break
      case 'delete':
        write({ type: 'delete', value: event.data })
        break
    }

    commit()
  })

  // 3. Perform initial data fetch
  async function initialSync() {
    try {
      const data = await fetchInitialData()

      begin() // Start a transaction

      for (const item of data) {
        write({
          type: 'insert',
          value: item
        })
      }

      commit() // Commit the transaction

      // 4. Process buffered events
      isInitialSyncComplete = true
      if (eventBuffer.length > 0) {
        begin()
        for (const event of eventBuffer) {
          // Deduplicate if necessary based on your sync engine
          write({ type: event.type, value: event.data })
        }
        commit()
        eventBuffer.splice(0)
      }

    } catch (error) {
      console.error('Initial sync failed:', error)
      throw error
    } finally {
      // ALWAYS call markReady, even on error
      markReady()
    }
  }

  initialSync()

  // 4. Return cleanup function
  return () => {
    connection.close()
    // Clean up any timers, intervals, or other resources
  }
}

```

```
const sync: SyncConfig<T>['sync'] = (params) => {
  const { begin, write, commit, markReady, collection } = params

  // 1. Initialize connection to your sync engine
  const connection = initializeConnection(config)

  // 2. Set up real-time subscription FIRST (prevents race conditions)
  const eventBuffer: Array<any> = []
  let isInitialSyncComplete = false

  connection.subscribe((event) => {
    if (!isInitialSyncComplete) {
      // Buffer events during initial sync to prevent race conditions
      eventBuffer.push(event)
      return
    }

    // Process real-time events
    begin()

    switch (event.type) {
      case 'insert':
        write({ type: 'insert', value: event.data })
        break
      case 'update':
        write({ type: 'update', value: event.data })
        break
      case 'delete':
        write({ type: 'delete', value: event.data })
        break
    }

    commit()
  })

  // 3. Perform initial data fetch
  async function initialSync() {
    try {
      const data = await fetchInitialData()

      begin() // Start a transaction

      for (const item of data) {
        write({
          type: 'insert',
          value: item
        })
      }

      commit() // Commit the transaction

      // 4. Process buffered events
      isInitialSyncComplete = true
      if (eventBuffer.length > 0) {
        begin()
        for (const event of eventBuffer) {
          // Deduplicate if necessary based on your sync engine
          write({ type: event.type, value: event.data })
        }
        commit()
        eventBuffer.splice(0)
      }

    } catch (error) {
      console.error('Initial sync failed:', error)
      throw error
    } finally {
      // ALWAYS call markReady, even on error
      markReady()
    }
  }

  initialSync()

  // 4. Return cleanup function
  return () => {
    connection.close()
    // Clean up any timers, intervals, or other resources
  }
}

```

[**3\. Transaction Lifecycle**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#3-transaction-lifecycle)

Understanding the transaction lifecycle is important for correct implementation.

The sync process follows this lifecycle:

1. **begin()** \- Start collecting changes
2. **write()** \- Add changes to the pending transaction (buffered until commit)
3. **commit()** \- Apply all changes atomically to the collection state
4. **markReady()** \- Signal that initial sync is complete

**Race Condition Prevention:**
Many sync engines start real-time subscriptions before the initial sync completes. Your implementation MUST deduplicate events that arrive via subscription that represent the same data as the initial sync. Consider:

- Starting the listener BEFORE initial fetch and buffering events
- Tracking timestamps, sequence numbers, or document versions
- Using read timestamps or other ordering mechanisms

[**4\. Data Parsing and Type Conversion**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#4-data-parsing-and-type-conversion)

If your sync engine returns data with different types, provide conversion functions for specific fields:

typescript

```
interface MyCollectionConfig<TItem, TRecord> {
  // ... other config

  // Only specify conversions for fields that need type conversion
  parse: {
    created_at: (ts: number) => new Date(ts * 1000),  // timestamp -> Date
    updated_at: (ts: number) => new Date(ts * 1000),  // timestamp -> Date
    metadata?: (str: string) => JSON.parse(str)       // JSON string -> object
  }

  serialize: {
    created_at: (date: Date) => Math.floor(date.valueOf() / 1000),  // Date -> timestamp
    updated_at: (date: Date) => Math.floor(date.valueOf() / 1000),  // Date -> timestamp
    metadata?: (obj: object) => JSON.stringify(obj)                 // object -> JSON string
  }
}

```

```
interface MyCollectionConfig<TItem, TRecord> {
  // ... other config

  // Only specify conversions for fields that need type conversion
  parse: {
    created_at: (ts: number) => new Date(ts * 1000),  // timestamp -> Date
    updated_at: (ts: number) => new Date(ts * 1000),  // timestamp -> Date
    metadata?: (str: string) => JSON.parse(str)       // JSON string -> object
  }

  serialize: {
    created_at: (date: Date) => Math.floor(date.valueOf() / 1000),  // Date -> timestamp
    updated_at: (date: Date) => Math.floor(date.valueOf() / 1000),  // Date -> timestamp
    metadata?: (obj: object) => JSON.stringify(obj)                 // object -> JSON string
  }
}

```

**Type Conversion Examples:**

typescript

```
// Firebase Timestamp to Date
parse: {
  createdAt: (timestamp) => timestamp?.toDate?.() || new Date(timestamp),
  updatedAt: (timestamp) => timestamp?.toDate?.() || new Date(timestamp),
}

// PostGIS geometry to GeoJSON
parse: {
  location: (wkb: string) => parseWKBToGeoJSON(wkb)
}

// JSON string to object with error handling
parse: {
  metadata: (str: string) => {
    try {
      return JSON.parse(str)
    } catch {
      return {}
    }
  }
}

```

```
// Firebase Timestamp to Date
parse: {
  createdAt: (timestamp) => timestamp?.toDate?.() || new Date(timestamp),
  updatedAt: (timestamp) => timestamp?.toDate?.() || new Date(timestamp),
}

// PostGIS geometry to GeoJSON
parse: {
  location: (wkb: string) => parseWKBToGeoJSON(wkb)
}

// JSON string to object with error handling
parse: {
  metadata: (str: string) => {
    try {
      return JSON.parse(str)
    } catch {
      return {}
    }
  }
}

```

[**5\. Mutation Handler Patterns**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#5-mutation-handler-patterns)

There are two distinct patterns for handling mutations in collection options creators:

[**Pattern A: User-Provided Handlers (ElectricSQL, Query)**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#pattern-a-user-provided-handlers-electricsql-query)

The user provides mutation handlers in the config. Your collection creator passes them through:

typescript

```
interface MyCollectionConfig<TItem extends object> {
  // ... other config

  // User provides these handlers
  onInsert?: InsertMutationFn<TItem>
  onUpdate?: UpdateMutationFn<TItem>
  onDelete?: DeleteMutationFn<TItem>
}

export function myCollectionOptions<TItem extends object>(
  config: MyCollectionConfig<TItem>
) {
  return {
    // ... other options
    rowUpdateMode: config.rowUpdateMode || 'partial',

    // Pass through user-provided handlers (possibly with additional logic)
    onInsert: config.onInsert ? async (params) => {
      const result = await config.onInsert!(params)
      // Additional sync coordination logic
      return result
    } : undefined
  }
}

```

```
interface MyCollectionConfig<TItem extends object> {
  // ... other config

  // User provides these handlers
  onInsert?: InsertMutationFn<TItem>
  onUpdate?: UpdateMutationFn<TItem>
  onDelete?: DeleteMutationFn<TItem>
}

export function myCollectionOptions<TItem extends object>(
  config: MyCollectionConfig<TItem>
) {
  return {
    // ... other options
    rowUpdateMode: config.rowUpdateMode || 'partial',

    // Pass through user-provided handlers (possibly with additional logic)
    onInsert: config.onInsert ? async (params) => {
      const result = await config.onInsert!(params)
      // Additional sync coordination logic
      return result
    } : undefined
  }
}

```

[**Pattern B: Built-in Handlers (Trailbase, WebSocket, Firebase)**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#pattern-b-built-in-handlers-trailbase-websocket-firebase)

Your collection creator implements the handlers directly using the sync engine's APIs:

typescript

```
interface MyCollectionConfig<TItem extends object>
  extends Omit<CollectionConfig<TItem>, 'onInsert' | 'onUpdate' | 'onDelete'> {
  // ... sync engine specific config
  // Note: onInsert/onUpdate/onDelete are NOT in the config
}

export function myCollectionOptions<TItem extends object>(
  config: MyCollectionConfig<TItem>
) {
  return {
    // ... other options
    rowUpdateMode: config.rowUpdateMode || 'partial',

    // Implement handlers using sync engine APIs
    onInsert: async ({ transaction }) => {
      // Handle provider-specific batch limits (e.g., Firestore's 500 limit)
      const chunks = chunkArray(transaction.mutations, PROVIDER_BATCH_LIMIT)

      for (const chunk of chunks) {
        const ids = await config.recordApi.createBulk(
          chunk.map(m => serialize(m.modified))
        )
        await awaitIds(ids)
      }

      return transaction.mutations.map(m => m.key)
    },

    onUpdate: async ({ transaction }) => {
      const chunks = chunkArray(transaction.mutations, PROVIDER_BATCH_LIMIT)

      for (const chunk of chunks) {
        await Promise.all(
          chunk.map(m =>
            config.recordApi.update(m.key, serialize(m.changes))
          )
        )
      }

      await awaitIds(transaction.mutations.map(m => String(m.key)))
    }
  }
}

```

```
interface MyCollectionConfig<TItem extends object>
  extends Omit<CollectionConfig<TItem>, 'onInsert' | 'onUpdate' | 'onDelete'> {
  // ... sync engine specific config
  // Note: onInsert/onUpdate/onDelete are NOT in the config
}

export function myCollectionOptions<TItem extends object>(
  config: MyCollectionConfig<TItem>
) {
  return {
    // ... other options
    rowUpdateMode: config.rowUpdateMode || 'partial',

    // Implement handlers using sync engine APIs
    onInsert: async ({ transaction }) => {
      // Handle provider-specific batch limits (e.g., Firestore's 500 limit)
      const chunks = chunkArray(transaction.mutations, PROVIDER_BATCH_LIMIT)

      for (const chunk of chunks) {
        const ids = await config.recordApi.createBulk(
          chunk.map(m => serialize(m.modified))
        )
        await awaitIds(ids)
      }

      return transaction.mutations.map(m => m.key)
    },

    onUpdate: async ({ transaction }) => {
      const chunks = chunkArray(transaction.mutations, PROVIDER_BATCH_LIMIT)

      for (const chunk of chunks) {
        await Promise.all(
          chunk.map(m =>
            config.recordApi.update(m.key, serialize(m.changes))
          )
        )
      }

      await awaitIds(transaction.mutations.map(m => String(m.key)))
    }
  }
}

```

Many providers have batch size limits (Firestore: 500, DynamoDB: 25, etc.) so chunk large transactions accordingly.

Choose Pattern A when users need to provide their own APIs, and Pattern B when your sync engine handles writes directly.

[**Row Update Modes**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#row-update-modes)

Collections support two update modes:

- **partial** (default) - Updates are merged with existing data
- **full** \- Updates replace the entire row

Configure this in your sync config:

typescript

```
sync: {
  sync: syncFn,
  rowUpdateMode: 'full' // or 'partial'
}

```

```
sync: {
  sync: syncFn,
  rowUpdateMode: 'full' // or 'partial'
}

```

[**Production Examples**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#production-examples)

For complete, production-ready examples, see the collection packages in the TanStack DB repository:

- **[@tanstack/query-collection](https://github.com/TanStack/db/tree/main/packages/query-collection)** \- Pattern A: User-provided handlers with full refetch strategy
- **[@tanstack/trailbase-collection](https://github.com/TanStack/db/tree/main/packages/trailbase-collection)** \- Pattern B: Built-in handlers with ID-based tracking
- **[@tanstack/electric-collection](https://github.com/TanStack/db/tree/main/packages/electric-collection)** \- Pattern A: Transaction ID tracking with complex sync protocols

[**Key Lessons from Production Collections**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#key-lessons-from-production-collections)

**From Query Collection:**

- Simplest approach: Full refetch after mutations
- Best for: APIs without real-time sync
- Pattern: User provides onInsert/onUpdate/onDelete handlers

**From Trailbase Collection:**

- Shows ID-based optimistic state management
- Handles provider batch limits (chunking large operations)
- Pattern: Collection provides mutation handlers using record API

**From Electric Collection:**

- Complex transaction ID tracking for distributed sync
- Demonstrates advanced deduplication techniques
- Shows how to wrap user handlers with sync coordination

[**Complete Example: WebSocket Collection**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#complete-example-websocket-collection)

Here's a complete example of a WebSocket-based collection options creator that demonstrates the full round-trip flow:

1. Client sends transaction with all mutations batched together
2. Server processes the transaction and may modify the data (validation, timestamps, etc.)
3. Server sends back acknowledgment and the actual processed data
4. Client waits for this round-trip before dropping optimistic state

typescript

```
import type {
  CollectionConfig,
  SyncConfig,
  InsertMutationFnParams,
  UpdateMutationFnParams,
  DeleteMutationFnParams,
  UtilsRecord
} from '@tanstack/db'

interface WebSocketMessage<T> {
  type: 'insert' | 'update' | 'delete' | 'sync' | 'transaction' | 'ack'
  data?: T | T[]
  mutations?: Array<{
    type: 'insert' | 'update' | 'delete'
    data: T
    id?: string
  }>
  transactionId?: string
  id?: string
}

interface WebSocketCollectionConfig<TItem extends object>
  extends Omit<CollectionConfig<TItem>, 'onInsert' | 'onUpdate' | 'onDelete' | 'sync'> {
  url: string
  reconnectInterval?: number

  // Note: onInsert/onUpdate/onDelete are handled by the WebSocket connection
  // Users don't provide these handlers
}

interface WebSocketUtils extends UtilsRecord {
  reconnect: () => void
  getConnectionState: () => 'connected' | 'disconnected' | 'connecting'
}

export function webSocketCollectionOptions<TItem extends object>(
  config: WebSocketCollectionConfig<TItem>
): CollectionConfig<TItem> & { utils: WebSocketUtils } {
  let ws: WebSocket | null = null
  let reconnectTimer: NodeJS.Timeout | null = null
  let connectionState: 'connected' | 'disconnected' | 'connecting' = 'disconnected'

  // Track pending transactions awaiting acknowledgment
  const pendingTransactions = new Map<string, {
    resolve: () => void
    reject: (error: Error) => void
    timeout: NodeJS.Timeout
  }>()

  const sync: SyncConfig<TItem>['sync'] = (params) => {
    const { begin, write, commit, markReady } = params

    function connect() {
      connectionState = 'connecting'
      ws = new WebSocket(config.url)

      ws.onopen = () => {
        connectionState = 'connected'
        // Request initial sync
        ws.send(JSON.stringify({ type: 'sync' }))
      }

      ws.onmessage = (event) => {
        const message: WebSocketMessage<TItem> = JSON.parse(event.data)

        switch (message.type) {
          case 'sync':
            // Initial sync with array of items
            begin()
            if (Array.isArray(message.data)) {
              for (const item of message.data) {
                write({ type: 'insert', value: item })
              }
            }
            commit()
            markReady()
            break

          case 'insert':
          case 'update':
          case 'delete':
            // Real-time updates from other clients
            begin()
            write({
              type: message.type,
              value: message.data as TItem
            })
            commit()
            break

          case 'ack':
            // Server acknowledged our transaction
            if (message.transactionId) {
              const pending = pendingTransactions.get(message.transactionId)
              if (pending) {
                clearTimeout(pending.timeout)
                pendingTransactions.delete(message.transactionId)
                pending.resolve()
              }
            }
            break

          case 'transaction':
            // Server sending back the actual data after processing our transaction
            if (message.mutations) {
              begin()
              for (const mutation of message.mutations) {
                write({
                  type: mutation.type,
                  value: mutation.data
                })
              }
              commit()
            }
            break
        }
      }

      ws.onerror = (error) => {
        console.error('WebSocket error:', error)
        connectionState = 'disconnected'
      }

      ws.onclose = () => {
        connectionState = 'disconnected'
        // Auto-reconnect
        if (!reconnectTimer) {
          reconnectTimer = setTimeout(() => {
            reconnectTimer = null
            connect()
          }, config.reconnectInterval || 5000)
        }
      }
    }

    // Start connection
    connect()

    // Return cleanup function
    return () => {
      if (reconnectTimer) {
        clearTimeout(reconnectTimer)
        reconnectTimer = null
      }
      if (ws) {
        ws.close()
        ws = null
      }
    }
  }

  // Helper function to send transaction and wait for server acknowledgment
  const sendTransaction = async (
    params: InsertMutationFnParams<TItem> | UpdateMutationFnParams<TItem> | DeleteMutationFnParams<TItem>
  ): Promise<void> => {
    if (ws?.readyState !== WebSocket.OPEN) {
      throw new Error('WebSocket not connected')
    }

    const transactionId = crypto.randomUUID()

    // Convert all mutations in the transaction to the wire format
    const mutations = params.transaction.mutations.map(mutation => ({
      type: mutation.type,
      id: mutation.key,
      data: mutation.type === 'delete' ? undefined :
           mutation.type === 'update' ? mutation.changes :
           mutation.modified
    }))

    // Send the entire transaction at once
    ws.send(JSON.stringify({
      type: 'transaction',
      transactionId,
      mutations
    }))

    // Wait for server acknowledgment
    return new Promise<void>((resolve, reject) => {
      const timeout = setTimeout(() => {
        pendingTransactions.delete(transactionId)
        reject(new Error(`Transaction ${transactionId} timed out`))
      }, 10000) // 10 second timeout

      pendingTransactions.set(transactionId, {
        resolve,
        reject,
        timeout
      })
    })
  }

  // All mutation handlers use the same transaction sender
  const onInsert = async (params: InsertMutationFnParams<TItem>) => {
    await sendTransaction(params)
  }

  const onUpdate = async (params: UpdateMutationFnParams<TItem>) => {
    await sendTransaction(params)
  }

  const onDelete = async (params: DeleteMutationFnParams<TItem>) => {
    await sendTransaction(params)
  }

  return {
    id: config.id,
    schema: config.schema,
    getKey: config.getKey,
    sync: { sync },
    onInsert,
    onUpdate,
    onDelete,
    utils: {
      reconnect: () => {
        if (ws) ws.close()
        connect()
      },
      getConnectionState: () => connectionState
    }
  }
}

```

```
import type {
  CollectionConfig,
  SyncConfig,
  InsertMutationFnParams,
  UpdateMutationFnParams,
  DeleteMutationFnParams,
  UtilsRecord
} from '@tanstack/db'

interface WebSocketMessage<T> {
  type: 'insert' | 'update' | 'delete' | 'sync' | 'transaction' | 'ack'
  data?: T | T[]
  mutations?: Array<{
    type: 'insert' | 'update' | 'delete'
    data: T
    id?: string
  }>
  transactionId?: string
  id?: string
}

interface WebSocketCollectionConfig<TItem extends object>
  extends Omit<CollectionConfig<TItem>, 'onInsert' | 'onUpdate' | 'onDelete' | 'sync'> {
  url: string
  reconnectInterval?: number

  // Note: onInsert/onUpdate/onDelete are handled by the WebSocket connection
  // Users don't provide these handlers
}

interface WebSocketUtils extends UtilsRecord {
  reconnect: () => void
  getConnectionState: () => 'connected' | 'disconnected' | 'connecting'
}

export function webSocketCollectionOptions<TItem extends object>(
  config: WebSocketCollectionConfig<TItem>
): CollectionConfig<TItem> & { utils: WebSocketUtils } {
  let ws: WebSocket | null = null
  let reconnectTimer: NodeJS.Timeout | null = null
  let connectionState: 'connected' | 'disconnected' | 'connecting' = 'disconnected'

  // Track pending transactions awaiting acknowledgment
  const pendingTransactions = new Map<string, {
    resolve: () => void
    reject: (error: Error) => void
    timeout: NodeJS.Timeout
  }>()

  const sync: SyncConfig<TItem>['sync'] = (params) => {
    const { begin, write, commit, markReady } = params

    function connect() {
      connectionState = 'connecting'
      ws = new WebSocket(config.url)

      ws.onopen = () => {
        connectionState = 'connected'
        // Request initial sync
        ws.send(JSON.stringify({ type: 'sync' }))
      }

      ws.onmessage = (event) => {
        const message: WebSocketMessage<TItem> = JSON.parse(event.data)

        switch (message.type) {
          case 'sync':
            // Initial sync with array of items
            begin()
            if (Array.isArray(message.data)) {
              for (const item of message.data) {
                write({ type: 'insert', value: item })
              }
            }
            commit()
            markReady()
            break

          case 'insert':
          case 'update':
          case 'delete':
            // Real-time updates from other clients
            begin()
            write({
              type: message.type,
              value: message.data as TItem
            })
            commit()
            break

          case 'ack':
            // Server acknowledged our transaction
            if (message.transactionId) {
              const pending = pendingTransactions.get(message.transactionId)
              if (pending) {
                clearTimeout(pending.timeout)
                pendingTransactions.delete(message.transactionId)
                pending.resolve()
              }
            }
            break

          case 'transaction':
            // Server sending back the actual data after processing our transaction
            if (message.mutations) {
              begin()
              for (const mutation of message.mutations) {
                write({
                  type: mutation.type,
                  value: mutation.data
                })
              }
              commit()
            }
            break
        }
      }

      ws.onerror = (error) => {
        console.error('WebSocket error:', error)
        connectionState = 'disconnected'
      }

      ws.onclose = () => {
        connectionState = 'disconnected'
        // Auto-reconnect
        if (!reconnectTimer) {
          reconnectTimer = setTimeout(() => {
            reconnectTimer = null
            connect()
          }, config.reconnectInterval || 5000)
        }
      }
    }

    // Start connection
    connect()

    // Return cleanup function
    return () => {
      if (reconnectTimer) {
        clearTimeout(reconnectTimer)
        reconnectTimer = null
      }
      if (ws) {
        ws.close()
        ws = null
      }
    }
  }

  // Helper function to send transaction and wait for server acknowledgment
  const sendTransaction = async (
    params: InsertMutationFnParams<TItem> | UpdateMutationFnParams<TItem> | DeleteMutationFnParams<TItem>
  ): Promise<void> => {
    if (ws?.readyState !== WebSocket.OPEN) {
      throw new Error('WebSocket not connected')
    }

    const transactionId = crypto.randomUUID()

    // Convert all mutations in the transaction to the wire format
    const mutations = params.transaction.mutations.map(mutation => ({
      type: mutation.type,
      id: mutation.key,
      data: mutation.type === 'delete' ? undefined :
           mutation.type === 'update' ? mutation.changes :
           mutation.modified
    }))

    // Send the entire transaction at once
    ws.send(JSON.stringify({
      type: 'transaction',
      transactionId,
      mutations
    }))

    // Wait for server acknowledgment
    return new Promise<void>((resolve, reject) => {
      const timeout = setTimeout(() => {
        pendingTransactions.delete(transactionId)
        reject(new Error(`Transaction ${transactionId} timed out`))
      }, 10000) // 10 second timeout

      pendingTransactions.set(transactionId, {
        resolve,
        reject,
        timeout
      })
    })
  }

  // All mutation handlers use the same transaction sender
  const onInsert = async (params: InsertMutationFnParams<TItem>) => {
    await sendTransaction(params)
  }

  const onUpdate = async (params: UpdateMutationFnParams<TItem>) => {
    await sendTransaction(params)
  }

  const onDelete = async (params: DeleteMutationFnParams<TItem>) => {
    await sendTransaction(params)
  }

  return {
    id: config.id,
    schema: config.schema,
    getKey: config.getKey,
    sync: { sync },
    onInsert,
    onUpdate,
    onDelete,
    utils: {
      reconnect: () => {
        if (ws) ws.close()
        connect()
      },
      getConnectionState: () => connectionState
    }
  }
}

```

[**Usage Example**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#usage-example)

typescript

```
import { createCollection } from '@tanstack/react-db'
import { webSocketCollectionOptions } from './websocket-collection'

const todos = createCollection(
  webSocketCollectionOptions({
    url: 'ws://localhost:8080/todos',
    getKey: (todo) => todo.id,
    schema: todoSchema
    // Note: No onInsert/onUpdate/onDelete - handled by WebSocket automatically
  })
)

// Use the collection
todos.insert({ id: '1', text: 'Buy milk', completed: false })

// Access utilities
todos.utils.getConnectionState() // 'connected'
todos.utils.reconnect() // Force reconnect

```

```
import { createCollection } from '@tanstack/react-db'
import { webSocketCollectionOptions } from './websocket-collection'

const todos = createCollection(
  webSocketCollectionOptions({
    url: 'ws://localhost:8080/todos',
    getKey: (todo) => todo.id,
    schema: todoSchema
    // Note: No onInsert/onUpdate/onDelete - handled by WebSocket automatically
  })
)

// Use the collection
todos.insert({ id: '1', text: 'Buy milk', completed: false })

// Access utilities
todos.utils.getConnectionState() // 'connected'
todos.utils.reconnect() // Force reconnect

```

[**Advanced: Managing Optimistic State**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#advanced-managing-optimistic-state)

A critical challenge in sync-first apps is knowing when to drop optimistic state. When a user makes a change:

1. The UI updates immediately (optimistic update)
2. A mutation is sent to the backend
3. The backend processes and persists the change
4. The change syncs back to the client
5. The optimistic state should be dropped in favor of the synced data

The key question is: **How do you know when step 4 is complete?**

[**Strategy 1: Built-in Provider Methods (Recommended)**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#strategy-1-built-in-provider-methods-recommended)

Many providers offer built-in methods to wait for sync completion:

typescript

```
// Firebase
await waitForPendingWrites(firestore)

// Custom WebSocket
await websocket.waitForAck(transactionId)

```

```
// Firebase
await waitForPendingWrites(firestore)

// Custom WebSocket
await websocket.waitForAck(transactionId)

```

[**Strategy 2: Transaction ID Tracking (ElectricSQL)**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#strategy-2-transaction-id-tracking-electricsql)

ElectricSQL returns transaction IDs that you can track:

typescript

```
// Track seen transaction IDs
const seenTxids = new Store<Set<number>>(new Set())

// In sync, track txids from incoming messages
if (message.headers.txids) {
  message.headers.txids.forEach(txid => {
    seenTxids.setState(prev => new Set([...prev, txid]))
  })
}

// Mutation handlers return txids and wait for them
const wrappedOnInsert = async (params) => {
  const result = await config.onInsert!(params)

  // Wait for the txid to appear in synced data
  if (result.txid) {
    await awaitTxId(result.txid)
  }

  return result
}

// Utility function to wait for a txid
const awaitTxId = (txId: number): Promise<boolean> => {
  if (seenTxids.state.has(txId)) return Promise.resolve(true)

  return new Promise((resolve) => {
    const unsubscribe = seenTxids.subscribe(() => {
      if (seenTxids.state.has(txId)) {
        unsubscribe()
        resolve(true)
      }
    })
  })
}

```

```
// Track seen transaction IDs
const seenTxids = new Store<Set<number>>(new Set())

// In sync, track txids from incoming messages
if (message.headers.txids) {
  message.headers.txids.forEach(txid => {
    seenTxids.setState(prev => new Set([...prev, txid]))
  })
}

// Mutation handlers return txids and wait for them
const wrappedOnInsert = async (params) => {
  const result = await config.onInsert!(params)

  // Wait for the txid to appear in synced data
  if (result.txid) {
    await awaitTxId(result.txid)
  }

  return result
}

// Utility function to wait for a txid
const awaitTxId = (txId: number): Promise<boolean> => {
  if (seenTxids.state.has(txId)) return Promise.resolve(true)

  return new Promise((resolve) => {
    const unsubscribe = seenTxids.subscribe(() => {
      if (seenTxids.state.has(txId)) {
        unsubscribe()
        resolve(true)
      }
    })
  })
}

```

[**Strategy 3: ID-Based Tracking (Trailbase)**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#strategy-3-id-based-tracking-trailbase)

Trailbase tracks when specific record IDs have been synced:

typescript

```
// Track synced IDs with timestamps
const seenIds = new Store(new Map<string, number>())

// In sync, mark IDs as seen
write({ type: 'insert', value: item })
seenIds.setState(prev => new Map(prev).set(item.id, Date.now()))

// Wait for specific IDs after mutations
const wrappedOnInsert = async (params) => {
  const ids = await config.recordApi.createBulk(items)

  // Wait for all IDs to be synced back
  await awaitIds(ids)
}

const awaitIds = (ids: string[]): Promise<void> => {
  const allSynced = ids.every(id => seenIds.state.has(id))
  if (allSynced) return Promise.resolve()

  return new Promise((resolve) => {
    const unsubscribe = seenIds.subscribe((state) => {
      if (ids.every(id => state.has(id))) {
        unsubscribe()
        resolve()
      }
    })
  })
}

```

```
// Track synced IDs with timestamps
const seenIds = new Store(new Map<string, number>())

// In sync, mark IDs as seen
write({ type: 'insert', value: item })
seenIds.setState(prev => new Map(prev).set(item.id, Date.now()))

// Wait for specific IDs after mutations
const wrappedOnInsert = async (params) => {
  const ids = await config.recordApi.createBulk(items)

  // Wait for all IDs to be synced back
  await awaitIds(ids)
}

const awaitIds = (ids: string[]): Promise<void> => {
  const allSynced = ids.every(id => seenIds.state.has(id))
  if (allSynced) return Promise.resolve()

  return new Promise((resolve) => {
    const unsubscribe = seenIds.subscribe((state) => {
      if (ids.every(id => state.has(id))) {
        unsubscribe()
        resolve()
      }
    })
  })
}

```

[**Strategy 4: Version/Timestamp Tracking**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#strategy-4-versiontimestamp-tracking)

Track version numbers or timestamps to detect when data is fresh:

typescript

```
// Track latest sync timestamp
let lastSyncTime = 0

// In mutations, record when the operation was sent
const wrappedOnUpdate = async (params) => {
  const mutationTime = Date.now()
  await config.onUpdate(params)

  // Wait for sync to catch up
  await waitForSync(mutationTime)
}

const waitForSync = (afterTime: number): Promise<void> => {
  if (lastSyncTime > afterTime) return Promise.resolve()

  return new Promise((resolve) => {
    const check = setInterval(() => {
      if (lastSyncTime > afterTime) {
        clearInterval(check)
        resolve()
      }
    }, 100)
  })
}

```

```
// Track latest sync timestamp
let lastSyncTime = 0

// In mutations, record when the operation was sent
const wrappedOnUpdate = async (params) => {
  const mutationTime = Date.now()
  await config.onUpdate(params)

  // Wait for sync to catch up
  await waitForSync(mutationTime)
}

const waitForSync = (afterTime: number): Promise<void> => {
  if (lastSyncTime > afterTime) return Promise.resolve()

  return new Promise((resolve) => {
    const check = setInterval(() => {
      if (lastSyncTime > afterTime) {
        clearInterval(check)
        resolve()
      }
    }, 100)
  })
}

```

[**Strategy 5: Full Refetch (Query Collection)**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#strategy-5-full-refetch-query-collection)

The query collection simply refetches all data after mutations:

typescript

```
const wrappedOnInsert = async (params) => {
  // Perform the mutation
  await config.onInsert(params)

  // Refetch the entire collection
  await refetch()

  // The refetch will trigger sync with fresh data,
  // automatically dropping optimistic state
}

```

```
const wrappedOnInsert = async (params) => {
  // Perform the mutation
  await config.onInsert(params)

  // Refetch the entire collection
  await refetch()

  // The refetch will trigger sync with fresh data,
  // automatically dropping optimistic state
}

```

[**Choosing a Strategy**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#choosing-a-strategy)

- **Built-in Methods**: Best when your provider offers sync completion APIs
- **Transaction IDs**: Best when your backend provides reliable transaction tracking
- **ID-Based**: Good for systems where each mutation returns the affected IDs
- **Full Refetch**: Simplest but least efficient; good for small datasets
- **Version/Timestamp**: Works when your sync includes reliable ordering information

[**Implementation Tips**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#implementation-tips)

1. **Always wait for sync** in your mutation handlers to ensure optimistic state is properly managed
2. **Handle timeouts** \- Don't wait forever for sync confirmation
3. **Clean up tracking data** \- Remove old txids/IDs to prevent memory leaks
4. **Provide utilities** \- Export functions like awaitTxId or awaitSync for advanced use cases

[**Best Practices**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#best-practices)

1. **Always call markReady()** \- This signals that the collection has initial data and is ready for use
2. **Handle errors gracefully** \- Call markReady() even on error to avoid blocking the app
3. **Clean up resources** \- Return a cleanup function from sync to prevent memory leaks
4. **Batch operations** \- Use begin/commit to batch multiple changes for better performance
5. **Race Conditions** \- Start listeners before initial fetch and buffer events
6. **Type safety** \- Use TypeScript generics to maintain type safety throughout
7. **Provide utilities** \- Export sync-engine-specific utilities for advanced use cases

[**Testing Your Collection**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#testing-your-collection)

Test your collection options creator with:

1. **Unit tests** \- Test sync logic, data transformations
2. **Integration tests** \- Test with real sync engine
3. **Error scenarios** \- Connection failures, invalid data
4. **Performance** \- Large datasets, frequent updates

[**Conclusion**](https://tanstack.com/db/latest/docs/guides/collection-options-creator#conclusion)

Creating a collection options creator allows you to integrate any sync engine with TanStack DB's powerful sync-first architecture. Follow the patterns shown here, and you'll have a robust, type-safe integration that provides excellent developer experience.

# createCollection

[**Function: createCollection()**](https://tanstack.com/db/latest/docs/reference/functions/createcollection#function-createcollection)

ts

```
function createCollection<TExplicit, TKey, TUtils, TSchema, TFallback>(options): Collection<ResolveType<TExplicit, TSchema, TFallback>, TKey, TUtils, TSchema, ResolveInsertInput<TExplicit, TSchema, TFallback>>

```

```
function createCollection<TExplicit, TKey, TUtils, TSchema, TFallback>(options): Collection<ResolveType<TExplicit, TSchema, TFallback>, TKey, TUtils, TSchema, ResolveInsertInput<TExplicit, TSchema, TFallback>>

```

Defined in: [packages/db/src/collection.ts:160](https://github.com/TanStack/db/blob/main/packages/db/src/collection.ts#L160)

Creates a new Collection instance with the given configuration

[**Type Parameters**](https://tanstack.com/db/latest/docs/reference/functions/createcollection#type-parameters)

â€¢ **TExplicit** = unknown

The explicit type of items in the collection (highest priority)

â€¢ **TKey** _extends_ string \| number = string \| number

The type of the key for the collection

â€¢ **TUtils** _extends_ [UtilsRecord](https://tanstack.com/db/latest/docs/reference/type-aliases/utilsrecord) = {}

The utilities record type

â€¢ **TSchema** _extends_ StandardSchemaV1<unknown, unknown\> = StandardSchemaV1<unknown, unknown>

The schema type for validation and type inference (second priority)

â€¢ **TFallback** _extends_ object = Record<string, unknown>

The fallback type if no explicit or schema type is provided

[**Parameters**](https://tanstack.com/db/latest/docs/reference/functions/createcollection#parameters) [**options**](https://tanstack.com/db/latest/docs/reference/functions/createcollection#options)

[CollectionConfig](https://tanstack.com/db/latest/docs/reference/interfaces/collectionconfig) < [ResolveType](https://tanstack.com/db/latest/docs/reference/type-aliases/resolvetype) <TExplicit, TSchema, TFallback>, TKey, TSchema, [ResolveInsertInput](https://tanstack.com/db/latest/docs/reference/type-aliases/resolveinsertinput) <TExplicit, TSchema, TFallback>\> & object

Collection options with optional utilities

[**Returns**](https://tanstack.com/db/latest/docs/reference/functions/createcollection#returns)

[Collection](https://tanstack.com/db/latest/docs/reference/interfaces/collection) < [ResolveType](https://tanstack.com/db/latest/docs/reference/type-aliases/resolvetype) <TExplicit, TSchema, TFallback>, TKey, TUtils, TSchema, [ResolveInsertInput](https://tanstack.com/db/latest/docs/reference/type-aliases/resolveinsertinput) <TExplicit, TSchema, TFallback>>

A new Collection with utilities exposed both at top level and under .utils

[**Examples**](https://tanstack.com/db/latest/docs/reference/functions/createcollection#examples)

ts

```
// Pattern 1: With operation handlers (direct collection calls)
const todos = createCollection({
  id: "todos",
  getKey: (todo) => todo.id,
  schema,
  onInsert: async ({ transaction, collection }) => {
    // Send to API
    await api.createTodo(transaction.mutations[0].modified)
  },
  onUpdate: async ({ transaction, collection }) => {
    await api.updateTodo(transaction.mutations[0].modified)
  },
  onDelete: async ({ transaction, collection }) => {
    await api.deleteTodo(transaction.mutations[0].key)
  },
  sync: { sync: () => {} }
})

// Direct usage (handlers manage transactions)
const tx = todos.insert({ id: "1", text: "Buy milk", completed: false })
await tx.isPersisted.promise

```

```
// Pattern 1: With operation handlers (direct collection calls)
const todos = createCollection({
  id: "todos",
  getKey: (todo) => todo.id,
  schema,
  onInsert: async ({ transaction, collection }) => {
    // Send to API
    await api.createTodo(transaction.mutations[0].modified)
  },
  onUpdate: async ({ transaction, collection }) => {
    await api.updateTodo(transaction.mutations[0].modified)
  },
  onDelete: async ({ transaction, collection }) => {
    await api.deleteTodo(transaction.mutations[0].key)
  },
  sync: { sync: () => {} }
})

// Direct usage (handlers manage transactions)
const tx = todos.insert({ id: "1", text: "Buy milk", completed: false })
await tx.isPersisted.promise

```

ts

```
// Pattern 2: Manual transaction management
const todos = createCollection({
  getKey: (todo) => todo.id,
  schema: todoSchema,
  sync: { sync: () => {} }
})

// Explicit transaction usage
const tx = createTransaction({
  mutationFn: async ({ transaction }) => {
    // Handle all mutations in transaction
    await api.saveChanges(transaction.mutations)
  }
})

tx.mutate(() => {
  todos.insert({ id: "1", text: "Buy milk" })
  todos.update("2", draft => { draft.completed = true })
})

await tx.isPersisted.promise

```

```
// Pattern 2: Manual transaction management
const todos = createCollection({
  getKey: (todo) => todo.id,
  schema: todoSchema,
  sync: { sync: () => {} }
})

// Explicit transaction usage
const tx = createTransaction({
  mutationFn: async ({ transaction }) => {
    // Handle all mutations in transaction
    await api.saveChanges(transaction.mutations)
  }
})

tx.mutate(() => {
  todos.insert({ id: "1", text: "Buy milk" })
  todos.update("2", draft => { draft.completed = true })
})

await tx.isPersisted.promise

```

ts

```
// Using schema for type inference (preferred as it also gives you client side validation)
const todoSchema = z.object({
  id: z.string(),
  title: z.string(),
  completed: z.boolean()
})

const todos = createCollection({
  schema: todoSchema,
  getKey: (todo) => todo.id,
  sync: { sync: () => {} }
})

// Note: You must provide either an explicit type or a schema, but not both.

```

```
// Using schema for type inference (preferred as it also gives you client side validation)
const todoSchema = z.object({
  id: z.string(),
  title: z.string(),
  completed: z.boolean()
})

const todos = createCollection({
  schema: todoSchema,
  getKey: (todo) => todo.id,
  sync: { sync: () => {} }
})

// Note: You must provide either an explicit type or a schema, but not both.

# createLiveQueryCollection

[**Function: createLiveQueryCollection()**](https://tanstack.com/db/latest/docs/reference/functions/createlivequerycollection#function-createlivequerycollection) [**Call Signature**](https://tanstack.com/db/latest/docs/reference/functions/createlivequerycollection#call-signature)

ts

```
function createLiveQueryCollection<TContext, TResult>(query): Collection<TResult, string | number, {}>

```

```
function createLiveQueryCollection<TContext, TResult>(query): Collection<TResult, string | number, {}>

```

Defined in: [packages/db/src/query/live-query-collection.ts:424](https://github.com/TanStack/db/blob/main/packages/db/src/query/live-query-collection.ts#L424)

Creates a live query collection directly

[**Type Parameters**](https://tanstack.com/db/latest/docs/reference/functions/createlivequerycollection#type-parameters)

â€¢ **TContext** _extends_ [Context](https://tanstack.com/db/latest/docs/reference/interfaces/context)

â€¢ **TResult** _extends_ object = { \[K in string \| number \| symbol\]: (TContext\["result"\] extends object ? any\[any\] : TContext\["hasJoins"\] extends true ? TContext\["schema"\] : TContext\["schema"\]\[TContext\["fromSourceName"\]\])\[K\] }

[**Parameters**](https://tanstack.com/db/latest/docs/reference/functions/createlivequerycollection#parameters) [**query**](https://tanstack.com/db/latest/docs/reference/functions/createlivequerycollection#query)

(q) =\> [QueryBuilder](https://tanstack.com/db/latest/docs/reference/type-aliases/querybuilder) <TContext>

[**Returns**](https://tanstack.com/db/latest/docs/reference/functions/createlivequerycollection#returns)

[Collection](https://tanstack.com/db/latest/docs/reference/interfaces/collection) <TResult, string \| number, {}>

[**Example**](https://tanstack.com/db/latest/docs/reference/functions/createlivequerycollection#example)

typescript

```
// Minimal usage - just pass a query function
const activeUsers = createLiveQueryCollection(
  (q) => q
    .from({ user: usersCollection })
    .where(({ user }) => eq(user.active, true))
    .select(({ user }) => ({ id: user.id, name: user.name }))
)

// Full configuration with custom options
const searchResults = createLiveQueryCollection({
  id: "search-results", // Custom ID (auto-generated if omitted)
  query: (q) => q
    .from({ post: postsCollection })
    .where(({ post }) => like(post.title, `%${searchTerm}%`))
    .select(({ post }) => ({
      id: post.id,
      title: post.title,
      excerpt: post.excerpt,
    })),
  getKey: (item) => item.id, // Custom key function (uses stream key if omitted)
  utils: {
    updateSearchTerm: (newTerm: string) => {
      // Custom utility functions
    }
  }
})

```

```
// Minimal usage - just pass a query function
const activeUsers = createLiveQueryCollection(
  (q) => q
    .from({ user: usersCollection })
    .where(({ user }) => eq(user.active, true))
    .select(({ user }) => ({ id: user.id, name: user.name }))
)

// Full configuration with custom options
const searchResults = createLiveQueryCollection({
  id: "search-results", // Custom ID (auto-generated if omitted)
  query: (q) => q
    .from({ post: postsCollection })
    .where(({ post }) => like(post.title, `%${searchTerm}%`))
    .select(({ post }) => ({
      id: post.id,
      title: post.title,
      excerpt: post.excerpt,
    })),
  getKey: (item) => item.id, // Custom key function (uses stream key if omitted)
  utils: {
    updateSearchTerm: (newTerm: string) => {
      // Custom utility functions
    }
  }
})

```

[**Call Signature**](https://tanstack.com/db/latest/docs/reference/functions/createlivequerycollection#call-signature-1)

ts

```
function createLiveQueryCollection<TContext, TResult, TUtils>(config): Collection<TResult, string | number, TUtils>

```

```
function createLiveQueryCollection<TContext, TResult, TUtils>(config): Collection<TResult, string | number, TUtils>

```

Defined in: [packages/db/src/query/live-query-collection.ts:432](https://github.com/TanStack/db/blob/main/packages/db/src/query/live-query-collection.ts#L432)

Creates a live query collection directly

[**Type Parameters**](https://tanstack.com/db/latest/docs/reference/functions/createlivequerycollection#type-parameters-1)

â€¢ **TContext** _extends_ [Context](https://tanstack.com/db/latest/docs/reference/interfaces/context)

â€¢ **TResult** _extends_ object = { \[K in string \| number \| symbol\]: (TContext\["result"\] extends object ? any\[any\] : TContext\["hasJoins"\] extends true ? TContext\["schema"\] : TContext\["schema"\]\[TContext\["fromSourceName"\]\])\[K\] }

â€¢ **TUtils** _extends_ [UtilsRecord](https://tanstack.com/db/latest/docs/reference/type-aliases/utilsrecord) = {}

[**Parameters**](https://tanstack.com/db/latest/docs/reference/functions/createlivequerycollection#parameters-1) [**config**](https://tanstack.com/db/latest/docs/reference/functions/createlivequerycollection#config)

[LiveQueryCollectionConfig](https://tanstack.com/db/latest/docs/reference/interfaces/livequerycollectionconfig) <TContext, TResult\> & object

[**Returns**](https://tanstack.com/db/latest/docs/reference/functions/createlivequerycollection#returns-1)

[Collection](https://tanstack.com/db/latest/docs/reference/interfaces/collection) <TResult, string \| number, TUtils>

[**Example**](https://tanstack.com/db/latest/docs/reference/functions/createlivequerycollection#example-1)

typescript

```
// Minimal usage - just pass a query function
const activeUsers = createLiveQueryCollection(
  (q) => q
    .from({ user: usersCollection })
    .where(({ user }) => eq(user.active, true))
    .select(({ user }) => ({ id: user.id, name: user.name }))
)

// Full configuration with custom options
const searchResults = createLiveQueryCollection({
  id: "search-results", // Custom ID (auto-generated if omitted)
  query: (q) => q
    .from({ post: postsCollection })
    .where(({ post }) => like(post.title, `%${searchTerm}%`))
    .select(({ post }) => ({
      id: post.id,
      title: post.title,
      excerpt: post.excerpt,
    })),
  getKey: (item) => item.id, // Custom key function (uses stream key if omitted)
  utils: {
    updateSearchTerm: (newTerm: string) => {
      // Custom utility functions
    }
  }
})

```

```
// Minimal usage - just pass a query function
const activeUsers = createLiveQueryCollection(
  (q) => q
    .from({ user: usersCollection })
    .where(({ user }) => eq(user.active, true))
    .select(({ user }) => ({ id: user.id, name: user.name }))
)

// Full configuration with custom options
const searchResults = createLiveQueryCollection({
  id: "search-results", // Custom ID (auto-generated if omitted)
  query: (q) => q
    .from({ post: postsCollection })
    .where(({ post }) => like(post.title, `%${searchTerm}%`))
    .select(({ post }) => ({
      id: post.id,
      title: post.title,
      excerpt: post.excerpt,
    })),
  getKey: (item) => item.id, // Custom key function (uses stream key if omitted)
  utils: {
    updateSearchTerm: (newTerm: string) => {
      // Custom utility functions
    }
  }
})

```

# electricCollectionOptions

[**Function: electricCollectionOptions()**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#function-electriccollectionoptions)

ts

```
function electricCollectionOptions<TExplicit, TSchema, TFallback>(config): object

```

```
function electricCollectionOptions<TExplicit, TSchema, TFallback>(config): object

```

Defined in: [packages/electric-db-collection/src/electric.ts:285](https://github.com/TanStack/db/blob/main/packages/electric-db-collection/src/electric.ts#L285)

Creates Electric collection options for use with a standard Collection

[**Type Parameters**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#type-parameters)

â€¢ **TExplicit** _extends_ Row<unknown\> = Row<unknown>

The explicit type of items in the collection (highest priority)

â€¢ **TSchema** _extends_ StandardSchemaV1<unknown, unknown\> = never

The schema type for validation and type inference (second priority)

â€¢ **TFallback** _extends_ Row<unknown\> = Row<unknown>

The fallback type if no explicit or schema type is provided

[**Parameters**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#parameters) [**config**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#config)

[ElectricCollectionConfig](https://tanstack.com/db/latest/docs/reference/electric-db-collection/interfaces/electriccollectionconfig) <TExplicit, TSchema, TFallback>

Configuration options for the Electric collection

[**Returns**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#returns)

object

Collection options with utilities

[**getKey()**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#getkey)

ts

```
getKey: (item) => string | number;

```

```
getKey: (item) => string | number;

```

[**Parameters**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#parameters-1) [**item**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#item)

ResolveType

[**Returns**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#returns-1)

string \| number

[**id?**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#id)

ts

```
optional id: string;

```

```
optional id: string;

```

All standard Collection configuration properties

[**onDelete**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#ondelete)

ts

```
onDelete:
  | undefined
  | (params) => Promise<{
  txid: number | number[];
 }> = wrappedOnDelete;

```

```
onDelete:
  | undefined
  | (params) => Promise<{
  txid: number | number[];
 }> = wrappedOnDelete;

```

[**onInsert**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#oninsert)

ts

```
onInsert:
  | undefined
  | (params) => Promise<{
  txid: number | number[];
 }> = wrappedOnInsert;

```

```
onInsert:
  | undefined
  | (params) => Promise<{
  txid: number | number[];
 }> = wrappedOnInsert;

```

[**onUpdate**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#onupdate)

ts

```
onUpdate:
  | undefined
  | (params) => Promise<{
  txid: number | number[];
 }> = wrappedOnUpdate;

```

```
onUpdate:
  | undefined
  | (params) => Promise<{
  txid: number | number[];
 }> = wrappedOnUpdate;

```

[**schema?**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#schema)

ts

```
optional schema: TSchema;

```

```
optional schema: TSchema;

```

[**sync**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#sync)

ts

```
sync: SyncConfig<ResolveType<TExplicit, TSchema, TFallback>, string | number>;

```

```
sync: SyncConfig<ResolveType<TExplicit, TSchema, TFallback>, string | number>;

```

[**utils**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#utils)

ts

```
utils: object;

```

```
utils: object;

```

[**utils.awaitTxId**](https://tanstack.com/db/latest/docs/reference/electric-db-collection/functions/electriccollectionoptions#utilsawaittxid)

ts

```
awaitTxId: AwaitTxIdFn;

```

```
awaitTxId: AwaitTxIdFn;

```